---
editor_options: 
  chunk_output_type: console
---
# Работа со строками

Видео-приветствие
"Всем привет! Меня зовут Юля. Я напомню вам о работе со строками в R. Мы посмотрим, как выглядят строки в R, как их можно соединять-разделять, какие функции есть для работы с ними (например,сортировка, поиск и замена подстроки, изменение регистра, транслитеряция и пр). Также мы потрогаем несколько удобных библиотек для работы со строковыми данными. Поехали!"

Работать со строками можно с помощью base R, но чаще всего удобнее пользоваться специальными пакетами:
* `stringr`, который входит в `tidyverse` ('str_')
* `stringi` ('stri_')

```{r libs}
library(tidyverse)
library(stringi)
```

## Запись строк

Для начала посмотрим, как можно получить строку.

* Присвоение

Надо вот так:

```{r}
string1 <- "Я строка"
string2 <- 'И я строка'
string1
string2
```

Вот так вот не надо:

```{r, error = TRUE}
string3 <- "Я тоже своего рода "строка"
string3
```

**NB!** Следите за кавычками

```{r}
string4 <- "Ну вот 'так' вроде норм"
string5 <- 'И "так" тоже'
string4
string5
```

Экранирование:

```{r}
string6 <- "Экранирование \"лишних\" кавычек"
string6
```

* Печать строки

Функции для печати строк вам, скорее всего, известны: `print`, `paste`, `paste0`, `cat`, `noquote`, `format`


```{r}
format(13.495902982, digits=5)
```

* Преобразование 

```{r}
typeof(4:7)
```

```{r}
as.character(4:7)
```

```{r}
string7 <- (1:9) ^ 2
toString (string7)
```

Преобразование таблиц в строки

**NB!** Функции `data.frame()`, `read.csv()`, `read.csv2()`, `read.table()` из base R по-умолчанию превращают строки в факторы. Чтобы этого избежать, необходимо указать аргумент `stringsAsFactors = FALSE`. 


```{r}
str(data.frame(letters[1:5], LETTERS[1:5]))
```


```{r}
str(data.frame(letters[1:5], LETTERS[1:5], stringsAsFactors = FALSE))
```

* Генерация

Генерация пустых строк

```{r}
character(3)
```

Генерация рандомных строк

```{r}
set.seed(42)
stri_rand_strings(n = 10, length = 5:14)
```

Генерация псевдорандомных строк (классический текст-заполнитель Lorem ipsum)

```{r}
stri_rand_lipsum(nparagraphs = 2)
```

* встроенные векторы

```{r}
letters
```

```{r}
LETTERS
```

```{r}
month.name
```

* чтение из файла

Чтение таблицы 
Функция `read_csv` взята из пакета  `readr`, который является частью `tidyverse`. Для чтения таблиц также есть функции `read_csv2()`, `read_tsv()` и `read_delim()`. В каких случаях они используются вы можете узнать в справке: `?read_csv2()`

```{r, message=FALSE}
sample <- read_csv("data/data_ficbook_untamed_sample.csv")
head(sample)
```

Чтение текста
Прочитать файл полностью можно с помощью функций из пакета `readr`: `read_file()` и `read_lines()`.
**NB!** `read_file()` будет работать очень долго, если размер текста большой.

```{r, message=FALSE}
my_file <- read_file("data/Cox_Forshaw_WHy_E_equals_mc_squared_ocr.txt")
my_file
```


## Количество символов

* Подсчет

Аналогом функции `nchar()` из базового R в пакете `stringr` является функция `str_length`.
**NB!** Эта функция может давать неверные значения, так как подсчитывает количество кодовых точек, используемых для кодирования символа. Чаще всего одному символу соответствует одна кодовая точка, но может быть и больше.

```{r}
str_length(c("Hello", "", NA))
```

Также для подсчета количества знаков в строке можно использовать функцию `str_count`, которая позволяет также подсчитывать количество паттернов (об этом  см. пункт о поиске подстроки ниже). Таблица `tibble` - аналог `data.frame`, используемый в библиотеке `tidyverse`. 


```{r}
tibble(mn = month.name) %>% 
  mutate(n_charactars = str_count(mn))
```

* Приведение к желаемому количеству

Иногда нам нужно соклатить строку до определенного количества символов. Это легко сделать с помощью функции `str_trinc()`. Например, можно сократить количество знаков в строке до 6 (по умолчанию индикатор сокращения - `ellipsis` - это многоточие):

```{r}
tibble(mn = month.name) %>% 
  mutate(mn_new = str_trunc(mn, width=6))
```

Функция позволяет также изменить индикатор сокращения и определить, сокращаем мы строку за счет ее начала, середины или конца:

```{r}
tibble(mn = month.name) %>% 
  mutate(mn_new = str_trunc(mn, 6, ellipsis = "-", side = "left"))
```

Обратная функция для "раздувания" строки - `str_pad`. По умолчанию это делается за счет пробелов " "

```{r}
tibble(mn = month.name) %>% 
  mutate(mn_new = str_pad(mn, 10))
```

Аргументы аналогичны:

```{r}
tibble(mn = month.name) %>% 
  mutate(mn_new = str_pad(mn, 10,  pad = ".", side = "both"))
```

Для форматирования строки в соответствии с определенной шириной и отступами используют функцию `str_wrap`. Например, попрорбуем представить первый параграф Lorem ipsum в виде строк с шириной не более 30 знаков (без переноса слов)

```{r}
some_txt <- stri_rand_lipsum(nparagraphs = 1)
cat(str_wrap(some_txt, width = 30))
```

Можно, например, указать отступ:

```{r}
cat(str_wrap(some_txt, width = 30, indent = 2), "\n")
```

Иногда в начале и/или конце строки присутствуют лишные пробелы, от которых нам хотелось бы избавиться. Для быстрого "отсечения" пробелов используют функцию `str_trim()`:

```{r}
raw_strings <- c("Эта ", " строка ", ", ", " имеет", " кучу", " пробелов ")

#Можно указать, с какой стороны убирать пробелы
str_trim(raw_strings, side = "left")

#А можно убрать с обоих концов
str_trim(raw_strings, side = "both")
```

## Сортировка

Вопрос выбора метода сортировки строк - не из самых простых. [Алгоритмов сортировки существует множество](https://www.youtube.com/watch?v=kPRA0W1kECg), скорость их работы отличается в зависимости от формата данных и способа их хранения. Для выбора алгоритма следует учитывать два аспекта: скорость его работы и объем необходимой памяти. 

![](https://i.imgur.com/D0zb2Tm.png) 

(с) [BigOcheatsheet] (https://www.bigocheatsheet.com/)

Для расчета сложности алгоритмов используется О-нотация, которая, грубо говоря, оценивает скорость роста функции, описывающей работу этого алгоритма. 
 
 
 ![](https://i.imgur.com/3ydrNff.png)
 
 (с) [BigOcheatsheet] (https://www.bigocheatsheet.com/)
 

Стандартное время работы алгоритмов сортировки - `O(nlogn)`, где `n` - это количество наблюдений (длина массива), однако для сортировки строк есть и более быстрые решения, например `MSD radix sort`, часто рекомендуемый для сортировки строк, со скоростью работы `O(kn)`, где `n` - это количество наблюдений, а `k` - количество разрядов. Визуализацию работы популярных алгоритмов сортировки можно увидеть [здесь](https://proglib.io/p/sort-gif/). В [этом видео](https://www.youtube.com/watch?v=6NwB5VFhM-Y) можно узнать, как начать разбираться в алгоритмах, если вам интересно. 

Таким образом, для сортировки больших массивов строковых данных в базовом R можно использовать функцию `sort()` с указанием метода `radix sort`: `sort(..., method = "radix")`

В пакете `stringr`для сортировки есть функции `str_sort` и `str_order`. Встроенный алгоритм сортировки в них не изменить, но зато можно задать локаль. 

```{r}
unsorted_strings <- c("a", "b", "ba", "e", "i", "б", "я")

#english
str_sort(unsorted_strings, locale = "en")

#hawaiian
str_sort(unsorted_strings, locale = "haw")

#default
str_sort(unsorted_strings)

#ukranian
str_sort(unsorted_strings, locale = "ru_UA")

```

**NB!** Знайте [локаль](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) своего компьютера, от нее зависит порядок сортировки. Функция `stringi::stri_locale_list()` покажет вам список локалей на компьютере. Ознакомьтесь также с `stringi::stri_locale_info` и `stringi::stri_locale_set`


## Конкатенация

Конкатенация - это операция склеивания, сцепления. Функция `str_c` позволяет склеивать строки в одну строку.

```{r}
str_c("h", "e", "l", "l", "o")

```

Можно указать разделитель аргументом `sep`:

```{r}
str_c("h", "e", "l", "l", "o", sep="_")

```

**NB!** NA выскакивают как NA, а пустые строки опускаются. Чтобы NA превратить в строку используйте `str_replace_na()`:


```{r}
x <- c("a", NA)
str_c("префикс-", x, "-суффикс")

str_c("префикс-", str_replace_na(x), "-суффикс")

```

Чтобы вектор строк превратить в одну строку воспользуйтесь аргументом `collapse`:
```{r}
x <- c("h", "e", "l", "l", "o")
str_c(x)

str_c(x, collapse = "_")

```

Обратная операция - разделение строк. Для этого можно использовать функции `separate()` или `str_split()`.

Используйте `separate()` для разбиения колонки из таблицы на несколько колонок

```{r}
head(sample) %>% 
  separate(col = author_link, into = c("column_1", "column_2", "author_id"), sep = "/")

```

Для преобразование строки в список из разделенных строк используйте `str_split()`. Например, если нам нужно узнать домен почты:

```{r}
dummy_emails <- c("andan@gmail.com", "icedone@mail.ru", "imdone@un.org")
str_split(dummy_emails, "@")
```

Кроме того, иногда вам может помочь функция `str_split_fixed()`, если у вас есть список строк, которые вам нужно разбить на части, у этих строк есть определенный паттерн, по которому они составлены, и вы всегда знаете, на сколько частей нужно эти строки разбить:

```{r}
dummy_books <- c("1974_Carrie_Doubleday", "1975_Salem's_lot_Doubleday", "1977_The_Shining_Doubleday")
#хотим список книг СМтивена Кингана 2 части
str_split_fixed(dummy_books, pattern="_", n=2)
```

Но это не всегда хорошо работает, поэтому существуют регулярные выражения:
```{r}
str_split_fixed(dummy_books, pattern="_", n=3)
```

## Работа с подстрокой

* Поиск подстроки

Функция `str_detect()` ищет подстроку в строке и возвращает TRUE или FALSE:

```{r}
tibble(mn = month.name) %>% 
  mutate(has_r = str_detect(mn, "r"))
```

А функция `str_which()` возвращает индекс элесента, в котором есть совпадение с подстрокой, которую ищут:

```{r}
str_which(month.name, "r")
```

```{r}
#фильтр по наличию подстроки
tibble(mn = month.name) %>% 
  slice(str_which(mn, "r"))
```

Если нужно вернуть не индекс, а сам элемент, в котором есть подстрока, можно также использовать `str_subset`:

```{r}
str_subset(month.name, "r")
```

`str_count()` возвращает количество вхождений данной подстроки в строке:

```{r}
str_count(month.name, "r")
```

Также в зависимости от задачи, вам могут пригодиться функции `str_locate()` и `str_locate_all()`

## Изменение строки

Ну и самый сок, наиболее часто используемые функции связаны с преобразованием строк. Особенно популярны при "чистке" данных. 

* Изменение регистра

Все просто, для приведения всех букв к заглавным используется `str_to_upper()`

```{r}
str_to_upper(month.name)
```

Чаще всего все буквы приводят к прописным:


```{r}
str_to_lower(month.name)
```

Можно и так

```{r}
str_to_title(some_txt)
```

* Выделение подстроки

Выделить подстроку из строки можно, указав индексы (`str_sub()`)...

```{r}
tibble(mn = month.name) %>% 
  mutate(mutate = str_sub(mn, start = 1, end = 3))
```

```{r}
tibble(mn = month.name) %>% 
  mutate(mutate = str_sub(mn, start = -3, end = -1))
```

... или указав сам паттерн (подстроку) (`str_extract()`)

```{r}
tibble(mn = month.name) %>% 
  mutate(mutate = str_extract(mn, "e"))
```

Как видите, в некоторых словах несколько букв e, но функция возвратила лишь одну. Это потому что `str_extract()` возвращает только первое вхождение. Для того, чтобы вернуть все вхождения подстроки, используйте `str_extract_all()`. Вам вернется список.

```{r}
str_extract_all(month.name, "e")
```

* замена подстроки

Функции `str_replace()` и `str_replace_all()` работают аналогично `str_extract()`, то есть первая заменчет только первое вхождение подстроки, а вторая заменяет все подстроки

```{r}
str_replace("September", "e", "E")
str_replace_all("September", "e", "E")
```

* Удаление подстроки

Аналогично работают `str_remove()` и `str_remove_all()`

```{r}
str_remove("September", "e")
str_remove_all("September", "e")
```

* Транслитерация строк

Пакет `stringi` позволяет производить транслитерацию строк. Методы можно посмотреть с помощью функции `stri_trans_list()`

```{r}
x <- "фанфик"

#транслитерация на английский - заметьте, не перевод
stri_trans_general(x, "cyrillic-latin")

#с английского на катакану
stri_trans_general("fanfic", "Latin-Katakana")

#с английского на хирагану
stri_trans_general("fanfic", "Latin-Hiragana")

#с английского на хангыль
stri_trans_general("fanfic", "Latn-Hang")
```

## Пакеты для работы с текстовыми данными

-определение языка
-расстояние между строками
-stylo
-ner (extract names)

## Задания

Итак

![](https://i.imgur.com/wfdQPVQ.jpg)

**Задание 1**
Представьте, что у вас есть оцифрованный текст (тот, что вы уже загрузили в my_file). Вам необходимо произвести его очистку, пока что теми средствами, что вы успели изучить. Этот текст - отрывок из книги Брайаня Кокса и Джеффа Форшоу "Что такое E=mc^2 и зачем нам это знать". Текст на русском, почти не содержит формул(=ими можно пренебречь). в нем есть сноски и заголовки. 

```{r, message=FALSE}
my_file
```

1. Имеет смысл разделить текст на параграфы по переносу строки `\n` `\r\n`. Это можно сделать с помощью `str_split()`. Не забудьте экранировать специальные символы!
2. Приведите все строки к нижнему регистру.
3. Необходимо избавиться от лишних табуляций `\t` и символов. Это текст на русском языке, нам же не нужны символы латинского алфавита? Лишние можно просто удалить или заменить на пробел.
4. Вы точно удалили все ненужные символы? Составьте сортированный список всех символов. Это можно сделать, временно склеив обратно в единый текст все параграфы. Потом с помощью `str_split()` разделить все знаки по пустой строке "". У вас получится список, переделайте его в вектор! Из вектора можно составить таблицу частотности символов, а из нее вытащить список названий строк и отсортировать его. NB! Не удаляйте символ переноса строки "-", если хотите сделать п.6.    
5. Проверьте длину строк. У вас есть пустые строки? Если есть, их можно удалить.
6*. Задание со звездочкой, выполнение опционально. Теперь надо разобраться с переносами строк, которые есть в печатных книгах, но нет в электронных текстах. Можно использовать цикл if: если предыдущая строка оканчивается на "-", то создай новую строку, склеенную из предыдущей и этой. В противном случае, создай новую строку из предыдущей и этой, разделенную пробелом. Не забудьте обработать крайние значения (первая и последняя строки).

**Задание 2**

Подготовим наши таблицы с фанфиками к обработке. 

```{r, message=FALSE}
sample %>% print()
```

1. Посмотрите на столбец authors_link. Нам же не нужен рудимент "	/authors/", оставшийся после скрэппинга? Удалите его.
2. ID автора гораздо легче использовать, чем его полный никнейм. Но у нас разное количество символов в ID. Нужно привести их к общей схеме, расширив строку до максимальной длины с помощью нулей, которые нужно вставить в начало строки.
3. Аналогичные манипуляции предлагаю проделать с ID работы из графы "link"
4*. Задание со звездочкой, выполнение опционально. Посмотрите на графу subtitle. Очевидно, у нас скачались отдельные главы фанфиков как отдельные фанфики. Нехорошо. Но! У нас также есть сборники фичков, которые и должны рассматриваться как отдельные фанфики (см. п. 13). Чем они отличаются? Наверное, наличием символов `"/"`, `"\"` или `"|"` в графе subtitle. Попробуйте соединить те тексты фичков, у которых совпадает ID и отсутствуют вышеперечисленные символы в названии. Количество лайков и страниц указывается для всего фанфика, а не для каждой главы, так что их можете не трогать.


## Sources

https://www.gastonsanchez.com/Handling_and_Processing_Strings_in_R.pdf
https://agricolamz.github.io/DS_for_DH/

