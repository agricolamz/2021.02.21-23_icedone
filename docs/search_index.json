[["index.html", "Зимняя школа АйсДан 2021: скрейпинг и анализ текстовых данных 1 О курсе", " Зимняя школа АйсДан 2021: скрейпинг и анализ текстовых данных М. Серветник, Ю. Мартысенко, Г. Мороз, Ф. Управителев 1 О курсе Материалы для курса зимней школы Анализа данных: скрейпинг и анализ текстовых данных. Пакеты: install.packages(c(&quot;tidyverse&quot;, &quot;stringi&quot;, &quot;data.table&quot;, &quot;rvest&quot;, &quot;gutenbergr&quot;, &quot;tidytext&quot;, &quot;wordcloud&quot;, &quot;tm&quot;, &quot;wesanderson&quot;, &quot;udpipe&quot;, &quot;ggwordcloud&quot;, &quot;igraph&quot;, &quot;ggraph&quot;, &quot;stopwords&quot;)) "],["работа-со-строками.html", "2 Работа со строками 2.1 Запись строк 2.2 Количество символов 2.3 Сортировка 2.4 Конкатенация 2.5 Работа с подстрокой 2.6 Изменение строки 2.7 Задания 2.8 Sources", " 2 Работа со строками Сейчас мы немного вспомним о работе со строками в R. Мы посмотрим, как выглядят строки в R, как их можно соединять-разделять, какие функции есть для работы с ними (например,сортировка, поиск и замена подстроки, изменение регистра, транслитеряция и пр). Также мы потрогаем несколько удобных библиотек для работы со строковыми данными. Поехали! Работать со строками можно с помощью base R, но чаще всего удобнее пользоваться специальными пакетами: * stringr, который входит в tidyverse (‘str_’) * stringi (‘stri_’) library(tidyverse) library(stringi) 2.1 Запись строк Для начала посмотрим, как можно получить строку. Присвоение Надо вот так: string1 &lt;- &quot;Я строка&quot; string2 &lt;- &#39;И я строка&#39; string1 ## [1] &quot;Я строка&quot; string2 ## [1] &quot;И я строка&quot; Вот так вот не надо: string3 &lt;- &quot;Я тоже своего рода &quot;строка&quot; string3 ## Error: &lt;text&gt;:1:33: unexpected symbol ## 1: string3 &lt;- &quot;Я тоже своего рода &quot;строка ## ^ NB! Следите за кавычками string4 &lt;- &quot;Ну вот &#39;так&#39; вроде норм&quot; string5 &lt;- &#39;И &quot;так&quot; тоже&#39; string4 ## [1] &quot;Ну вот &#39;так&#39; вроде норм&quot; string5 ## [1] &quot;И \\&quot;так\\&quot; тоже&quot; Экранирование специальных символов: string6 &lt;- &quot;Экранирование \\&quot;лишних\\&quot; кавычек&quot; string6 ## [1] &quot;Экранирование \\&quot;лишних\\&quot; кавычек&quot; R (как и другие языки) может читать текст вместе со специальными управляющими символами (такими, например, являются кавычки ' и \" или бэкслэш \\), а может читать просто как текст. Если символов мало, то их можно экранировать, добавив перед ними бэкслэш. Если много, можно использовать специальную функцию для отключения экранинования и переведения всех символов в “сырые” (=читаются как текст) R\"()\" - см. подсказки в справке ?Quotes. Печать строки Функции для печати строк вам, скорее всего, известны: print, paste, paste0, cat, noquote, format format(13.495902982, digits=5) ## [1] &quot;13.496&quot; Преобразование typeof(4:7) ## [1] &quot;integer&quot; as.character(4:7) ## [1] &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; string7 &lt;- (1:9) ^ 2 toString (string7) ## [1] &quot;1, 4, 9, 16, 25, 36, 49, 64, 81&quot; Преобразование таблиц в строки NB! Функции data.frame(), read.csv(), read.csv2(), read.table() из base R до последней версии R по-умолчанию превращали строки в факторы. Если ваша версия R младше 4.0.0, то чтобы избежать превращения строк в факторы, необходимо указывать аргумент stringsAsFactors = FALSE. str(data.frame(letters[1:5], LETTERS[1:5], stringsAsFactors = TRUE)) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ letters.1.5.: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 ## $ LETTERS.1.5.: Factor w/ 5 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 1 2 3 4 5 str(data.frame(letters[1:5], LETTERS[1:5], stringsAsFactors = FALSE)) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ letters.1.5.: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ LETTERS.1.5.: chr &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... Генерация Генерация пустых строк character(3) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; Генерация рандомных строк set.seed(42) stri_rand_strings(n = 10, length = 5:14) ## [1] &quot;uwHpd&quot; &quot;Wj8ehS&quot; &quot;ivFSwy7&quot; &quot;TYu8zw5V&quot; ## [5] &quot;OuRpjoOg0&quot; &quot;p0CubNR2yQ&quot; &quot;xtdycKLOm2k&quot; &quot;fAGVfylZqBGp&quot; ## [9] &quot;gE28DTCi0NV0a&quot; &quot;9MemYE55If0Cvv&quot; Генерация псевдорандомных строк (классический текст-заполнитель Lorem ipsum) stri_rand_lipsum(nparagraphs = 2) ## [1] &quot;Lorem ipsum dolor sit amet, non, consectetur aliquam mollis velit accumsan condimentum sit sed. Eu dapibus habitant faucibus interdum vel? Libero amet lacus aliquam ac sit, porta? Leo leo dolor enim eu rutrum volutpat posuere, pulvinar, inceptos bibendum aliquam quis. Laoreet vulputate inceptos posuere eu, id vel pretium eu eu. Ut in urna ac laoreet scelerisque hendrerit. Metus integer purus nec, purus parturient dolor eget quis pharetra tristique. Donec in lacus vehicula orci, ligula faucibus per. Sem amet tempus nascetur, tincidunt euismod pellentesque sit? In vitae ligula nec pellentesque sed hac. Curabitur ut semper lectus justo ut suspendisse ut at faucibus dolor. Nec non neque senectus donec sit nunc. Urna sed, ultricies, ac pharetra orci luctus, iaculis ac.&quot; ## [2] &quot;Tincidunt cum neque eu semper at sociosqu hendrerit eu aliquet lacus, eu hendrerit. Donec aliquam eros risus nibh quam in sit facilisi ipsum. Amet sem sed donec sed molestie, scelerisque tincidunt nisl. Donec et facilisis interdum non sed dolor purus in ipsum, dignissim torquent velit. Nec aliquam pellentesque, ac adipiscing neque et at torquent. Vestibulum ullamcorper ad dictumst. Enim velit non nulla, felis habitant egestas placerat consectetur. Dictum nostra sed nec. Erat phasellus dolor libero aliquam viverra, vestibulum leo et suscipit. Egestas in in montes sapien gravida conubia purus varius ut nec. Feugiat, risus eleifend magnis neque diam suspendisse ullamcorper nulla adipiscing, malesuada massa nisi.&quot; встроенные векторы letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; чтение из файла Чтение таблицы Чтение таблицы Функция read_csv взята из пакета readr, который является частью tidyverse. Для чтения таблиц также есть функции read_csv2(), read_tsv() и read_delim(). В каких случаях они используются вы можете узнать в справке, добавив перед именем функции вопросительный знак: ?read_csv2() sample &lt;- read_csv(&quot;data/data_ficbook_untamed_sample.csv&quot;) head(sample) Чтение текста Прочитать файл полностью можно с помощью функций из пакета readr: read_file() и read_lines(). NB! read_file() будет работать очень долго, если размер текста большой. my_file &lt;- read_file(&quot;data/Cox_Forshaw_WHy_E_equals_mc_squared_ocr.txt&quot;) my_file ## [1] &quot;ПОМI N1% /;\\r\\nIII г2’»\\r\\nпо\\tона может принимать разные\\r\\n„ труднее определить.\\t„„ происходило, общее к„.\\r\\nЭнергию Р&gt; тоЧНо очевиден.\\tаТЬСя неизменным не-\\r\\n,;.г,ои процессе\\tэмми №тер дала нам\\r\\nзависимо от изменения других\\tп&lt;)Т0Му, что законы физики\\r\\nглубокое объяснение. Энергия ^\\tутверЖде„ие не означает, что\\r\\nис изменяются с течением прем\\tосто бессмысленно. На самом\\r\\n„„чего не происходит - это Ьъ спрапедлипы сегодня, деле оно означает, что если уН»\\tВы можете заменить ело-\\r\\nто „ни должны быть 2»™Л;В“ла,, любым другим фундаментальным\\r\\nвосочетание «уравнения Максвелл\\tмер.\\r\\nзаконом физики-постулатами Эинште\\tимпульса, закон со-\\r\\nВместе с тем, как и в случае закона сохранения . У ^\\t„\\r\\nхранения энергии был открыт экспериментальным )\\t•\\r\\nоткрытия восходит к промышленной революции. Все началось с раоо эксиериментаторов-практиков, которые обнаружили множество с. „„четких и химических явлений в поисках промышленного Иерусалима-К числу таких людей относился и несчастный граф Румфорд Баварский (рожденный под именем Бенджамин Томпсон в Массачусетсе в 1753 году I, работа которого состояла в высверливании каналов в пушечных стволах для армии герцога Баварии. В процессе работы он обратил внимание, что металл пушечного ствола и сверло нагреваются, и справедливо предположил, что вращательное движение сверла превращается в тепло под воздействием трения. Это прямо противоположно тому, что происходит в паровом двигателе, где тепло преобразуется во вращательное движение колес поезда. Казалось вполне естественным связать некую общую величину с теплом и вращательным движением, поскольку, как выяснилось эти две на первый взгляд совершенно разные вещи взаимозаменяемы Эта величина - энергия. Румфорда называли несчастным, потому что\\r\\nон женился на вдове другого великого ученого, Антуана Л тш,-\\r\\n’\\t7 ,ав&gt;лзье, после\\r\\nтого как тот во время Французской революции сложил голову н » п\\r\\nтине. Румфорд ошибочно решил, что эта женщина будет делать дЛ},\\r\\nто же, что и для Лавуазье, прилежно записывая все результаты СГо *\\&quot; °\\r\\nботы и повинуясь ему, как полагалось хорошей жене в XVIII ст,„1СПи Но оказалось, она проявляла кроткость только под давлением железног\\r\\nра-\\r\\nолетиц.\\r\\nпо\\r\\n«ЕМ*\\r\\nЖ*\\r\\n(. тс*7\\r\\nII\\r\\n, л..у&gt;»&#39;- в св°ей ммеЧаТе\\&quot;ЬНОЙ книге 1 Ьс Оием Гог АЬзо1ц1с 2его-Мендельсон писал, что эта женщина превратила жизнь графа Ру„.\\r\\nВ1\\r\\nКУРТ\\r\\n„ „ яп Но главное не это, а то, что энергия всегда соуп™ ,\\r\\nхорда в ад-\\t_\\tг ^да сохраняется, имен-\\r\\n* п^тШу она вызывает такой интерес.\\r\\nяо ПОЭ 7\\r\\nПопросите кого-либо на улице объяснить, что такое энергия, -й получите либо осмысленный ответ, либо кучу всякого вздора в духе „ью-эйдж” В массовой культуре существует много разных значений слова «энергия», поскольку оно употребляется очень широко. Следует отметить, однако, что на самом деле есть точное определение энергии, которое нельзя использовать для объяснения лей-линий***, исцеления кристаллами, жизни после смерти или реинкарнации. Здравомыслящий человек мог бы сказать, что энергию можно хранить внутри аккумуляторной батареи, где она находится в состоянии ожидания до тех пор, пока кто-то не «замкнет цепь». Кто-то другой, возможно, возразит, что энергия — это показатель количества движения и что быстро движущиеся объекты обладают большей энергией, чем более медленные. Энергия, которую содержит море или ветер, — вот еще примеры определений. Вам могут также сказать, что горячие объекты содержат больше энергии, чем холодные. Гигантский маховик, который находится вн\\\\ три электростанции, может накапливать энергию, которая высвобожда ется затем в электросеть для удовлетворения потребностей населения в электроэнергии. Кроме того, энергия выделяется в процессе деления .томного ядра. Это только несколько примеров присутствия энергии в повседневной жизни. Во всех этих сяучаях физик,, могут представить\\r\\nгЬпоме и использовать эту информацию для энергию в количественной фор«\\t^\\t,ффеИ\\r\\nподведения\\t“менным общее количество энергии,\\r\\nлюбого процесса сохран\\r\\n--------------- Мендельсон К. А. Г. На пути к абсолютному нулю: Вве-\\r\\n* ИЗДаНЗ «&#39;у низких температур. М.: Атомиздат. 1971. пение в физику ”\\r\\nм\\t^\\tокупности различных мистических течении и движе-\\r\\nОбщее название со УгноГО, эзотерического и синкретического характера.\\r\\nНИЙ. В ОСНОВНОМ окк&gt;\\r\\nПрим, ред-\\t^ места на поверхности Земли, которым свойственно прояв-\\r\\n... Предположителен _ энеррии&gt;&gt; Прим авт_\\r\\nление\\r\\n112\\r\\nсохранения энергии в действу\\r\\n. . . .у-П 1\\\\|« 111\\r\\nДпя того чтобы увидеть закон сохр,,,.^...\\r\\nследпии раз вернемся к сталкивающимся билья &#39;\\r\\n-»\\&quot;«й из них обладает определенной\\t«ч-*\\r\\nтог\\r\\nв ПОС\\r\\nм\\r\\n:д.\\r\\nю№ 11\\t«***•«*з........,«* ««у»\\t««««^\\r\\n“;„Г«ое,о да»*&#39;»»\\&quot;&#39; Некого языка слоя., «кинетический. ^\\r\\nили возникающий вследствие яви*..,,\\r\\nделястся как «обусло\\r\\n— * и\\r\\nтермин. Ранее мы исходили из того, что д„а 111а^ ____стью и имеют одинаковую массу. Затем &lt;*,\\r\\nтак что это правильный\\t....\\r\\nс одинаковом скор0^ -^ ^ ^ с равной скоростью в проп\\r\\n— - -ал»* 11/ЭПЛ Г* ПТЧП !«!/&gt;.\\r\\nДВИЖУТСЯ С ОДИН» --- •\\r\\nсталкиваются и отскакивают И —■ ^ значите/1ЬНОЙ мере продиктова\\r\\nположных направлениях. .\\tтщательный анализ ситуации па\\r\\n.законом сохранения импульса. Б««™*\\tле\\r\\nзлоллет определить, что скорость движения шар\\r\\nнемного ...к. их скорости „о столкновения. Это объясняется темли\\r\\nчаек начальной энергии рассеялась во время столкновения. Наиболее\\r\\nочевидное рассеяние энергии — переход ее части в звук. Когда бильярд\\r\\nные шары сталкиваются друг с другом, они воздействуют на молек.\\r\\nвоздуха, и это возмущение достигает наших ушей. Таким образом, час:\\r\\nначальной энергии теряется, из-за чего у шаров после столкновения оста\\r\\nется меньше энергии. С точки зрения темы данной книги нам на само *\\r\\nделе не нужно знать, как измерить энергию во всех ее проявлениях, хот-\\r\\nфьрмул. кинетической энергии нал, „се же пригодится немного позже\\r\\nКаждый, кто изучал л средней школе физику, навсегда запомнил эту фор мулу, кинетическая энергия = в п\\tД запомнил ЭТ\\\\ ^ г\\r\\nвыразить в количественной ф„р2„е одним чисдТмТ ЧТ° ЭНЧ&gt;\\&quot;\\&quot;“ лмчество энергии в системе всегда о г .\\tТ“КЖе ЧТО ООЩсе\\r\\nА \\&quot;\\&quot;Ч\\&quot;- вернемся к нашему разговор’\\&quot; К&#39;иам*«\\&quot;ЫМ.\\r\\n‘ \\&quot; к&#39;1,4 1ве примера величины, котоиа\\tЫ \\&quot;Паи1 кониепцию импуль\\r\\nс гиер&#39;ией практическая польз. ймпу„ьёГ“й“*“*\\&quot;* “ектоР°М Наряд)\\r\\n&#39;Управлении движения о *НИз&gt; на юго-ВОСТо 5 СЧетУ вектор им\\r\\nсклонность разделять \\&quot;\\&quot;\\&quot; \\&quot;Рц1ы«У1ЧУЮ глав! \\&quot; &#39;\\&quot;\\&quot;Йом «РУ™ -Ипм-У«ныстрел^.Г:;;е^;Р»пст1........... лр^ «окаэшиГи.\\r\\n&#39; ““\\&quot;“‘■«ы» четыре ЭТО«6лУжде-\\r\\nНапРпвле„„ях\\r\\nч\\r\\n\\r\\nЖЕ *\\r\\n\\r\\nII .4\\r\\nПГ1\\r\\nнства-времени, в противном случае мы так и не сможем соста-лГнламеИтальные уравнения с учетом теории Эйнштейна. Позволь-■Г^овторнтв еще раз: фундаментальные уравнения должны включать г* ,я объекты, существующие в пространстве-времени, а не объекты, * ествующие отдельно в пространстве или во времени, поскольку ь^ъекты такого типа носят субъективный характер. Если вы помните, [в*размер объекта в пространстве, ни промежуток времени между двумя мбытиями нельзя отнести к категории величин, со значением которых\\r\\nсогласятся все без исключения. Именно это мы имеем в виду, утверждая, что такие объекты носят субъективный характер. Импульс также представляет собой вектор, направленный куда-то только в пространстве. Такое предубеждение против времени сеет семена его разрушения. Предве щает ли пространство-время крушение этого самого фундаментального из всех законов физики? Вновь открытая структура пространства-времени действительно сеет семена разрушения, но она указывает нам так же дальнейший путь: нам необходимо найти инвариантную величину, которая сможет занять место устаревшего трехмерного импульса. А вот и ключевой момент нашего повествования: такая величина существует Давайте внимательнее взглянем на трехмерный вектор импульса. На рис. 11 он представлен в виде стрелки, которая может отображать рас стояние, на которое откатывается шар, перемещаясь по столу*. Если опи-\\r\\nсывать ситуацию точнее, то предположим, что в полдень шар находи гем\\r\\nУ одного конца этой стрелки, а через две секунды — у другого. Если шар перемещается на сантиметр каждую секунду, тогда длина стрелки равна Двум сантиметрам. Получить вектор импульса не составляет проблем Он представляет собой стрелку, указывающую абсолютно в том же на\\r\\nправлении, что и на рис. 11, но ее длина другая и равна скорости нашего Шара (в данном случае один сантиметр в секунду), умноженной на его массу, которая составляет, к примеру, десять граммов. Физики сказали бы, что вектор импульса этого шара имеет длину десять грамм сантиметров в секунду (в краткой форме они записали бы это гак: 10 I&#39; • см/с). Здесь снова целесообразно ввести абстрактные символы, вместо юго чтобы\\r\\n■ В выборе шара нет ничего особенного. Вместо него можно было бы выбрать любой другой объект.\\r\\n&quot; 2.2 Количество символов Подсчет Аналогом функции nchar() из базового R в пакете stringr является функция str_length. NB! Эта функция может давать неверные значения, так как подсчитывает количество кодовых точек, используемых для кодирования символа. Чаще всего одному символу соответствует одна кодовая точка, но может быть и больше. str_length(c(&quot;Hello&quot;, &quot;&quot;, NA)) ## [1] 5 0 NA Также для подсчета количества знаков в строке можно использовать функцию str_count, которая позволяет также подсчитывать количество паттернов (об этом см. пункт о поиске подстроки ниже). Таблица tibble - аналог data.frame, используемый в библиотеке tidyverse. tibble(mn = month.name) %&gt;% mutate(n_charactars = str_count(mn)) Приведение к желаемому количеству Иногда нам нужно соклатить строку до определенного количества символов. Это легко сделать с помощью функции str_trunc(). Например, можно сократить количество знаков в строке до 6 (по умолчанию индикатор сокращения - ellipsis - это многоточие): tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, width=6)) Функция позволяет также изменить индикатор сокращения и определить, сокращаем мы строку за счет ее начала, середины или конца: tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6, ellipsis = &quot;-&quot;, side = &quot;left&quot;)) Обратная функция для “раздувания” строки - str_pad(). По умолчанию это делается за счет пробелов \" \" tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10)) Аргументы аналогичны: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10, pad = &quot;.&quot;, side = &quot;both&quot;)) Для форматирования строки в соответствии с определенной шириной и отступами используют функцию str_wrap(). Например, попрорбуем представить первый параграф Lorem ipsum в виде строк с шириной не более 30 знаков (без переноса слов) some_txt &lt;- stri_rand_lipsum(nparagraphs = 1) cat(str_wrap(some_txt, width = 30)) ## Lorem ipsum dolor sit ## amet, metus integer iaculis ## tincidunt ac orci convallis. ## Metus duis neque ligula ## natoque nostra vel montes ## fringilla. Efficitur arcu ## dolor vel et diam, tincidunt, ## rhoncus, ad donec. Rutrum ## mauris ornare suspendisse ## justo, vehicula id diam, ## mollis ut. Velit et eu, mauris ## nunc vestibulum sapien. Augue ## dignissim vulputate montes ## ipsum rutrum, eu, eu. Porta ## faucibus maximus ac fusce ## placerat. In imperdiet libero ## cum conubia lacus. Ornare ## tempor vel nam, pulvinar, ## imperdiet sit, vestibulum ## ipsum orci. Можно, например, указать отступ: cat(str_wrap(some_txt, width = 30, indent = 2), &quot;\\n&quot;) ## Lorem ipsum dolor sit ## amet, metus integer iaculis ## tincidunt ac orci convallis. ## Metus duis neque ligula ## natoque nostra vel montes ## fringilla. Efficitur arcu ## dolor vel et diam, tincidunt, ## rhoncus, ad donec. Rutrum ## mauris ornare suspendisse ## justo, vehicula id diam, ## mollis ut. Velit et eu, mauris ## nunc vestibulum sapien. Augue ## dignissim vulputate montes ## ipsum rutrum, eu, eu. Porta ## faucibus maximus ac fusce ## placerat. In imperdiet libero ## cum conubia lacus. Ornare ## tempor vel nam, pulvinar, ## imperdiet sit, vestibulum ## ipsum orci. Иногда в начале и/или конце строки присутствуют лишные пробелы, от которых нам хотелось бы избавиться. Для быстрого “отсечения” пробелов используют функцию str_trim(): raw_strings &lt;- c(&quot;Эта &quot;, &quot; строка &quot;, &quot;, &quot;, &quot; имеет&quot;, &quot; кучу&quot;, &quot; пробелов &quot;) #Можно указать, с какой стороны убирать пробелы str_trim(raw_strings, side = &quot;left&quot;) ## [1] &quot;Эта &quot; &quot;строка &quot; &quot;, &quot; &quot;имеет&quot; &quot;кучу&quot; &quot;пробелов &quot; #А можно убрать с обоих концов str_trim(raw_strings, side = &quot;both&quot;) ## [1] &quot;Эта&quot; &quot;строка&quot; &quot;,&quot; &quot;имеет&quot; &quot;кучу&quot; &quot;пробелов&quot; 2.3 Сортировка Вопрос выбора метода сортировки строк - не из самых простых. Алгоритмов сортировки существует множество, скорость их работы отличается в зависимости от формата данных и способа их хранения. Для выбора алгоритма следует учитывать два аспекта: скорость его работы и объем необходимой памяти. (с) [BigOcheatsheet] (https://www.bigocheatsheet.com/) Для расчета сложности алгоритмов используется О-нотация, которая, грубо говоря, оценивает скорость роста функции, описывающей работу этого алгоритма. (с) [BigOcheatsheet] (https://www.bigocheatsheet.com/) Стандартное время работы алгоритмов сортировки - логарифмическое, т.е. O(nlogn), где n - это количество наблюдений (длина массива), однако для сортировки строк есть и более быстрые решения, например MSD radix sort с линейной скоростью работы O(kn), где n - это количество наблюдений, а k - количество разрядов. Визуализацию работы популярных алгоритмов сортировки можно увидеть здесь. В этом видео можно узнать, как начать разбираться в алгоритмах, если вам интересно. Таким образом, для сортировки больших массивов строковых данных в базовом R можно использовать функцию sort() с указанием метода radix sort: sort(..., method = \"radix\") В пакете stringrдля сортировки есть функции str_sort() и str_order(). Встроенный алгоритм сортировки в них не изменить, но зато можно задать локаль. unsorted_strings &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;e&quot;, &quot;i&quot;, &quot;б&quot;, &quot;я&quot;) #english str_sort(unsorted_strings, locale = &quot;en&quot;) ## [1] &quot;a&quot; &quot;b&quot; &quot;ba&quot; &quot;e&quot; &quot;i&quot; &quot;б&quot; &quot;я&quot; #hawaiian str_sort(unsorted_strings, locale = &quot;haw&quot;) ## [1] &quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;b&quot; &quot;ba&quot; &quot;б&quot; &quot;я&quot; #default str_sort(unsorted_strings) ## [1] &quot;a&quot; &quot;b&quot; &quot;ba&quot; &quot;e&quot; &quot;i&quot; &quot;б&quot; &quot;я&quot; #ukranian str_sort(unsorted_strings, locale = &quot;ru_UA&quot;) ## [1] &quot;б&quot; &quot;я&quot; &quot;a&quot; &quot;b&quot; &quot;ba&quot; &quot;e&quot; &quot;i&quot; NB! Знайте локаль своего компьютера, от нее зависит порядок сортировки. Функция stringi::stri_locale_list() покажет вам список локалей на компьютере. Ознакомьтесь также с stringi::stri_locale_info и stringi::stri_locale_set 2.4 Конкатенация Конкатенация - это операция склеивания, сцепления. Функция str_c() позволяет склеивать строки в одну строку. str_c(&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;) ## [1] &quot;hello&quot; Можно указать разделитель аргументом sep: str_c(&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, sep=&quot;_&quot;) ## [1] &quot;h_e_l_l_o&quot; NB! NA выскакивают как NA, а пустые строки опускаются. Чтобы NA превратить в строку используйте str_replace_na(): x &lt;- c(&quot;a&quot;, NA) str_c(&quot;префикс-&quot;, x, &quot;-суффикс&quot;) ## [1] &quot;префикс-a-суффикс&quot; NA str_c(&quot;префикс-&quot;, str_replace_na(x), &quot;-суффикс&quot;) ## [1] &quot;префикс-a-суффикс&quot; &quot;префикс-NA-суффикс&quot; Чтобы вектор строк превратить в одну строку воспользуйтесь аргументом collapse: x &lt;- c(&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;) str_c(x) ## [1] &quot;h&quot; &quot;e&quot; &quot;l&quot; &quot;l&quot; &quot;o&quot; str_c(x, collapse = &quot;_&quot;) ## [1] &quot;h_e_l_l_o&quot; Обратная операция - разделение строк. Для этого можно использовать функции separate() или str_split(). Используйте separate() для разбиения колонки из таблицы на несколько колонок head(sample) %&gt;% separate(col = author_link, into = c(&quot;column_1&quot;, &quot;column_2&quot;, &quot;author_id&quot;), sep = &quot;/&quot;) Для преобразование строки в список из разделенных строк используйте str_split(). Например, если нам нужно узнать домен почты: dummy_emails &lt;- c(&quot;andan@gmail.com&quot;, &quot;icedone@mail.ru&quot;, &quot;imdone@un.org&quot;) str_split(dummy_emails, &quot;@&quot;) ## [[1]] ## [1] &quot;andan&quot; &quot;gmail.com&quot; ## ## [[2]] ## [1] &quot;icedone&quot; &quot;mail.ru&quot; ## ## [[3]] ## [1] &quot;imdone&quot; &quot;un.org&quot; Кроме того, иногда вам может помочь функция str_split_fixed(), если у вас есть список строк, которые вам нужно разбить на части, у этих строк есть определенный паттерн, по которому они составлены, и вы всегда знаете, на сколько частей нужно эти строки разбить: dummy_books &lt;- c(&quot;1974_Carrie_Doubleday&quot;, &quot;1975_Salem&#39;s_lot_Doubleday&quot;, &quot;1977_The_Shining_Doubleday&quot;) #хотим список книг СМтивена Кингана 2 части str_split_fixed(dummy_books, pattern=&quot;_&quot;, n=2) ## [,1] [,2] ## [1,] &quot;1974&quot; &quot;Carrie_Doubleday&quot; ## [2,] &quot;1975&quot; &quot;Salem&#39;s_lot_Doubleday&quot; ## [3,] &quot;1977&quot; &quot;The_Shining_Doubleday&quot; Но это не всегда хорошо работает (поэтому существуют регулярные выражения): str_split_fixed(dummy_books, pattern=&quot;_&quot;, n=3) ## [,1] [,2] [,3] ## [1,] &quot;1974&quot; &quot;Carrie&quot; &quot;Doubleday&quot; ## [2,] &quot;1975&quot; &quot;Salem&#39;s&quot; &quot;lot_Doubleday&quot; ## [3,] &quot;1977&quot; &quot;The&quot; &quot;Shining_Doubleday&quot; 2.5 Работа с подстрокой Поиск подстроки Функция str_detect() ищет подстроку в строке и возвращает TRUE или FALSE: tibble(mn = month.name) %&gt;% mutate(has_r = str_detect(mn, &quot;r&quot;)) А функция str_which() возвращает индекс элемента, в котором есть совпадение с подстрокой, которую ищут: str_which(month.name, &quot;r&quot;) ## [1] 1 2 3 4 9 10 11 12 #фильтр по наличию подстроки tibble(mn = month.name) %&gt;% slice(str_which(mn, &quot;r&quot;)) Если нужно вернуть не индекс, а сам элемент, в котором есть подстрока, можно также использовать str_subset(): str_subset(month.name, &quot;r&quot;) ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;September&quot; &quot;October&quot; ## [7] &quot;November&quot; &quot;December&quot; str_count() возвращает количество вхождений данной подстроки в строке: str_count(month.name, &quot;r&quot;) ## [1] 1 2 1 1 0 0 0 0 1 1 1 1 Также в зависимости от задачи, вам могут пригодиться функции str_locate() и str_locate_all() 2.6 Изменение строки Ну и самый сок, наиболее часто используемые функции связаны с преобразованием строк. Особенно популярны при “чистке” данных. Изменение регистра Все просто, для приведения всех букв к заглавным используется str_to_upper() str_to_upper(month.name) ## [1] &quot;JANUARY&quot; &quot;FEBRUARY&quot; &quot;MARCH&quot; &quot;APRIL&quot; &quot;MAY&quot; &quot;JUNE&quot; ## [7] &quot;JULY&quot; &quot;AUGUST&quot; &quot;SEPTEMBER&quot; &quot;OCTOBER&quot; &quot;NOVEMBER&quot; &quot;DECEMBER&quot; Чаще всего все буквы приводят к прописным: str_to_lower(month.name) ## [1] &quot;january&quot; &quot;february&quot; &quot;march&quot; &quot;april&quot; &quot;may&quot; &quot;june&quot; ## [7] &quot;july&quot; &quot;august&quot; &quot;september&quot; &quot;october&quot; &quot;november&quot; &quot;december&quot; Можно и так str_to_title(some_txt) ## [1] &quot;Lorem Ipsum Dolor Sit Amet, Metus Integer Iaculis Tincidunt Ac Orci Convallis. Metus Duis Neque Ligula Natoque Nostra Vel Montes Fringilla. Efficitur Arcu Dolor Vel Et Diam, Tincidunt, Rhoncus, Ad Donec. Rutrum Mauris Ornare Suspendisse Justo, Vehicula Id Diam, Mollis Ut. Velit Et Eu, Mauris Nunc Vestibulum Sapien. Augue Dignissim Vulputate Montes Ipsum Rutrum, Eu, Eu. Porta Faucibus Maximus Ac Fusce Placerat. In Imperdiet Libero Cum Conubia Lacus. Ornare Tempor Vel Nam, Pulvinar, Imperdiet Sit, Vestibulum Ipsum Orci.&quot; Выделение подстроки Выделить подстроку из строки можно, указав индексы (str_sub())… tibble(mn = month.name) %&gt;% mutate(mutate = str_sub(mn, start = 1, end = 3)) tibble(mn = month.name) %&gt;% mutate(mutate = str_sub(mn, start = -3, end = -1)) … или указав сам паттерн (подстроку) (str_extract()) tibble(mn = month.name) %&gt;% mutate(mutate = str_extract(mn, &quot;e&quot;)) Как видите, в некоторых словах несколько букв e, но функция возвратила лишь одну. Это потому что str_extract() возвращает только первое вхождение. Для того, чтобы вернуть все вхождения подстроки, используйте str_extract_all(). Вам вернется список. str_extract_all(month.name, &quot;e&quot;) ## [[1]] ## character(0) ## ## [[2]] ## [1] &quot;e&quot; ## ## [[3]] ## character(0) ## ## [[4]] ## character(0) ## ## [[5]] ## character(0) ## ## [[6]] ## [1] &quot;e&quot; ## ## [[7]] ## character(0) ## ## [[8]] ## character(0) ## ## [[9]] ## [1] &quot;e&quot; &quot;e&quot; &quot;e&quot; ## ## [[10]] ## [1] &quot;e&quot; ## ## [[11]] ## [1] &quot;e&quot; &quot;e&quot; ## ## [[12]] ## [1] &quot;e&quot; &quot;e&quot; &quot;e&quot; замена подстроки Функции str_replace() и str_replace_all() работают аналогично str_extract(), то есть первая заменчет только первое вхождение подстроки, а вторая заменяет все подстроки str_replace(&quot;September&quot;, &quot;e&quot;, &quot;E&quot;) ## [1] &quot;SEptember&quot; str_replace_all(&quot;September&quot;, &quot;e&quot;, &quot;E&quot;) ## [1] &quot;SEptEmbEr&quot; Удаление подстроки Аналогично работают str_remove() и str_remove_all() str_remove(&quot;September&quot;, &quot;e&quot;) ## [1] &quot;Sptember&quot; str_remove_all(&quot;September&quot;, &quot;e&quot;) ## [1] &quot;Sptmbr&quot; Транслитерация строк Пакет stringi позволяет производить транслитерацию строк. Методы можно посмотреть с помощью функции stri_trans_list() x &lt;- &quot;фанфик&quot; #транслитерация на английский - заметьте, не перевод stri_trans_general(x, &quot;cyrillic-latin&quot;) ## [1] &quot;fanfik&quot; #с английского на катакану stri_trans_general(&quot;fanfic&quot;, &quot;Latin-Katakana&quot;) ## [1] &quot;ファンフィク&quot; #с английского на хирагану stri_trans_general(&quot;fanfic&quot;, &quot;Latin-Hiragana&quot;) ## [1] &quot;ふぁんふぃく&quot; #с английского на хангыль stri_trans_general(&quot;fanfic&quot;, &quot;Latn-Hang&quot;) ## [1] &quot;판핓&quot; 2.7 Задания Итак Представьте, что у вас есть оцифрованный текст (тот, что вы уже загрузили в my_file). Вам необходимо произвести его очистку, пока что теми средствами, что вы успели изучить. Этот текст - отрывок из книги Брайаня Кокса и Джеффа Форшоу “Что такое E=mc^2 и зачем нам это знать.” Текст на русском, почти не содержит формул(=ими можно пренебречь). в нем есть сноски и заголовки. my_file ## [1] &quot;ПОМI N1% /;\\r\\nIII г2’»\\r\\nпо\\tона может принимать разные\\r\\n„ труднее определить.\\t„„ происходило, общее к„.\\r\\nЭнергию Р&gt; тоЧНо очевиден.\\tаТЬСя неизменным не-\\r\\n,;.г,ои процессе\\tэмми №тер дала нам\\r\\nзависимо от изменения других\\tп&lt;)Т0Му, что законы физики\\r\\nглубокое объяснение. Энергия ^\\tутверЖде„ие не означает, что\\r\\nис изменяются с течением прем\\tосто бессмысленно. На самом\\r\\n„„чего не происходит - это Ьъ спрапедлипы сегодня, деле оно означает, что если уН»\\tВы можете заменить ело-\\r\\nто „ни должны быть 2»™Л;В“ла,, любым другим фундаментальным\\r\\nвосочетание «уравнения Максвелл\\tмер.\\r\\nзаконом физики-постулатами Эинште\\tимпульса, закон со-\\r\\nВместе с тем, как и в случае закона сохранения . У ^\\t„\\r\\nхранения энергии был открыт экспериментальным )\\t•\\r\\nоткрытия восходит к промышленной революции. Все началось с раоо эксиериментаторов-практиков, которые обнаружили множество с. „„четких и химических явлений в поисках промышленного Иерусалима-К числу таких людей относился и несчастный граф Румфорд Баварский (рожденный под именем Бенджамин Томпсон в Массачусетсе в 1753 году I, работа которого состояла в высверливании каналов в пушечных стволах для армии герцога Баварии. В процессе работы он обратил внимание, что металл пушечного ствола и сверло нагреваются, и справедливо предположил, что вращательное движение сверла превращается в тепло под воздействием трения. Это прямо противоположно тому, что происходит в паровом двигателе, где тепло преобразуется во вращательное движение колес поезда. Казалось вполне естественным связать некую общую величину с теплом и вращательным движением, поскольку, как выяснилось эти две на первый взгляд совершенно разные вещи взаимозаменяемы Эта величина - энергия. Румфорда называли несчастным, потому что\\r\\nон женился на вдове другого великого ученого, Антуана Л тш,-\\r\\n’\\t7 ,ав&gt;лзье, после\\r\\nтого как тот во время Французской революции сложил голову н » п\\r\\nтине. Румфорд ошибочно решил, что эта женщина будет делать дЛ},\\r\\nто же, что и для Лавуазье, прилежно записывая все результаты СГо *\\&quot; °\\r\\nботы и повинуясь ему, как полагалось хорошей жене в XVIII ст,„1СПи Но оказалось, она проявляла кроткость только под давлением железног\\r\\nра-\\r\\nолетиц.\\r\\nпо\\r\\n«ЕМ*\\r\\nЖ*\\r\\n(. тс*7\\r\\nII\\r\\n, л..у&gt;»&#39;- в св°ей ммеЧаТе\\&quot;ЬНОЙ книге 1 Ьс Оием Гог АЬзо1ц1с 2его-Мендельсон писал, что эта женщина превратила жизнь графа Ру„.\\r\\nВ1\\r\\nКУРТ\\r\\n„ „ яп Но главное не это, а то, что энергия всегда соуп™ ,\\r\\nхорда в ад-\\t_\\tг ^да сохраняется, имен-\\r\\n* п^тШу она вызывает такой интерес.\\r\\nяо ПОЭ 7\\r\\nПопросите кого-либо на улице объяснить, что такое энергия, -й получите либо осмысленный ответ, либо кучу всякого вздора в духе „ью-эйдж” В массовой культуре существует много разных значений слова «энергия», поскольку оно употребляется очень широко. Следует отметить, однако, что на самом деле есть точное определение энергии, которое нельзя использовать для объяснения лей-линий***, исцеления кристаллами, жизни после смерти или реинкарнации. Здравомыслящий человек мог бы сказать, что энергию можно хранить внутри аккумуляторной батареи, где она находится в состоянии ожидания до тех пор, пока кто-то не «замкнет цепь». Кто-то другой, возможно, возразит, что энергия — это показатель количества движения и что быстро движущиеся объекты обладают большей энергией, чем более медленные. Энергия, которую содержит море или ветер, — вот еще примеры определений. Вам могут также сказать, что горячие объекты содержат больше энергии, чем холодные. Гигантский маховик, который находится вн\\\\ три электростанции, может накапливать энергию, которая высвобожда ется затем в электросеть для удовлетворения потребностей населения в электроэнергии. Кроме того, энергия выделяется в процессе деления .томного ядра. Это только несколько примеров присутствия энергии в повседневной жизни. Во всех этих сяучаях физик,, могут представить\\r\\nгЬпоме и использовать эту информацию для энергию в количественной фор«\\t^\\t,ффеИ\\r\\nподведения\\t“менным общее количество энергии,\\r\\nлюбого процесса сохран\\r\\n--------------- Мендельсон К. А. Г. На пути к абсолютному нулю: Вве-\\r\\n* ИЗДаНЗ «&#39;у низких температур. М.: Атомиздат. 1971. пение в физику ”\\r\\nм\\t^\\tокупности различных мистических течении и движе-\\r\\nОбщее название со УгноГО, эзотерического и синкретического характера.\\r\\nНИЙ. В ОСНОВНОМ окк&gt;\\r\\nПрим, ред-\\t^ места на поверхности Земли, которым свойственно прояв-\\r\\n... Предположителен _ энеррии&gt;&gt; Прим авт_\\r\\nление\\r\\n112\\r\\nсохранения энергии в действу\\r\\n. . . .у-П 1\\\\|« 111\\r\\nДпя того чтобы увидеть закон сохр,,,.^...\\r\\nследпии раз вернемся к сталкивающимся билья &#39;\\r\\n-»\\&quot;«й из них обладает определенной\\t«ч-*\\r\\nтог\\r\\nв ПОС\\r\\nм\\r\\n:д.\\r\\nю№ 11\\t«***•«*з........,«* ««у»\\t««««^\\r\\n“;„Г«ое,о да»*&#39;»»\\&quot;&#39; Некого языка слоя., «кинетический. ^\\r\\nили возникающий вследствие яви*..,,\\r\\nделястся как «обусло\\r\\n— * и\\r\\nтермин. Ранее мы исходили из того, что д„а 111а^ ____стью и имеют одинаковую массу. Затем &lt;*,\\r\\nтак что это правильный\\t....\\r\\nс одинаковом скор0^ -^ ^ ^ с равной скоростью в проп\\r\\n— - -ал»* 11/ЭПЛ Г* ПТЧП !«!/&gt;.\\r\\nДВИЖУТСЯ С ОДИН» --- •\\r\\nсталкиваются и отскакивают И —■ ^ значите/1ЬНОЙ мере продиктова\\r\\nположных направлениях. .\\tтщательный анализ ситуации па\\r\\n.законом сохранения импульса. Б««™*\\tле\\r\\nзлоллет определить, что скорость движения шар\\r\\nнемного ...к. их скорости „о столкновения. Это объясняется темли\\r\\nчаек начальной энергии рассеялась во время столкновения. Наиболее\\r\\nочевидное рассеяние энергии — переход ее части в звук. Когда бильярд\\r\\nные шары сталкиваются друг с другом, они воздействуют на молек.\\r\\nвоздуха, и это возмущение достигает наших ушей. Таким образом, час:\\r\\nначальной энергии теряется, из-за чего у шаров после столкновения оста\\r\\nется меньше энергии. С точки зрения темы данной книги нам на само *\\r\\nделе не нужно знать, как измерить энергию во всех ее проявлениях, хот-\\r\\nфьрмул. кинетической энергии нал, „се же пригодится немного позже\\r\\nКаждый, кто изучал л средней школе физику, навсегда запомнил эту фор мулу, кинетическая энергия = в п\\tД запомнил ЭТ\\\\ ^ г\\r\\nвыразить в количественной ф„р2„е одним чисдТмТ ЧТ° ЭНЧ&gt;\\&quot;\\&quot;“ лмчество энергии в системе всегда о г .\\tТ“КЖе ЧТО ООЩсе\\r\\nА \\&quot;\\&quot;Ч\\&quot;- вернемся к нашему разговор’\\&quot; К&#39;иам*«\\&quot;ЫМ.\\r\\n‘ \\&quot; к&#39;1,4 1ве примера величины, котоиа\\tЫ \\&quot;Паи1 кониепцию импуль\\r\\nс гиер&#39;ией практическая польз. ймпу„ьёГ“й“*“*\\&quot;* “ектоР°М Наряд)\\r\\n&#39;Управлении движения о *НИз&gt; на юго-ВОСТо 5 СЧетУ вектор им\\r\\nсклонность разделять \\&quot;\\&quot;\\&quot; \\&quot;Рц1ы«У1ЧУЮ глав! \\&quot; &#39;\\&quot;\\&quot;Йом «РУ™ -Ипм-У«ныстрел^.Г:;;е^;Р»пст1........... лр^ «окаэшиГи.\\r\\n&#39; ““\\&quot;“‘■«ы» четыре ЭТО«6лУжде-\\r\\nНапРпвле„„ях\\r\\nч\\r\\n\\r\\nЖЕ *\\r\\n\\r\\nII .4\\r\\nПГ1\\r\\nнства-времени, в противном случае мы так и не сможем соста-лГнламеИтальные уравнения с учетом теории Эйнштейна. Позволь-■Г^овторнтв еще раз: фундаментальные уравнения должны включать г* ,я объекты, существующие в пространстве-времени, а не объекты, * ествующие отдельно в пространстве или во времени, поскольку ь^ъекты такого типа носят субъективный характер. Если вы помните, [в*размер объекта в пространстве, ни промежуток времени между двумя мбытиями нельзя отнести к категории величин, со значением которых\\r\\nсогласятся все без исключения. Именно это мы имеем в виду, утверждая, что такие объекты носят субъективный характер. Импульс также представляет собой вектор, направленный куда-то только в пространстве. Такое предубеждение против времени сеет семена его разрушения. Предве щает ли пространство-время крушение этого самого фундаментального из всех законов физики? Вновь открытая структура пространства-времени действительно сеет семена разрушения, но она указывает нам так же дальнейший путь: нам необходимо найти инвариантную величину, которая сможет занять место устаревшего трехмерного импульса. А вот и ключевой момент нашего повествования: такая величина существует Давайте внимательнее взглянем на трехмерный вектор импульса. На рис. 11 он представлен в виде стрелки, которая может отображать рас стояние, на которое откатывается шар, перемещаясь по столу*. Если опи-\\r\\nсывать ситуацию точнее, то предположим, что в полдень шар находи гем\\r\\nУ одного конца этой стрелки, а через две секунды — у другого. Если шар перемещается на сантиметр каждую секунду, тогда длина стрелки равна Двум сантиметрам. Получить вектор импульса не составляет проблем Он представляет собой стрелку, указывающую абсолютно в том же на\\r\\nправлении, что и на рис. 11, но ее длина другая и равна скорости нашего Шара (в данном случае один сантиметр в секунду), умноженной на его массу, которая составляет, к примеру, десять граммов. Физики сказали бы, что вектор импульса этого шара имеет длину десять грамм сантиметров в секунду (в краткой форме они записали бы это гак: 10 I&#39; • см/с). Здесь снова целесообразно ввести абстрактные символы, вместо юго чтобы\\r\\n■ В выборе шара нет ничего особенного. Вместо него можно было бы выбрать любой другой объект.\\r\\n&quot; Имеет смысл разделить текст на параграфы по переносу строки \\n \\r\\n. Это можно сделать с помощью str_split(). Не забудьте экранировать специальные символы! Приведите все строки к нижнему регистру. Необходимо избавиться от лишних табуляций \\t и символов. Это текст на русском языке, нам же не нужны символы латинского алфавита? Лишние можно просто удалить или заменить на пробел. Вы точно удалили все ненужные символы? Составьте сортированный список всех символов. Это можно сделать, временно склеив обратно в единый текст все параграфы. Потом с помощью str_split() разделить все знаки по пустой строке \"“. У вас получится список, переделайте его в вектор! Из вектора можно составить таблицу частотности символов, а из нее вытащить список названий строк и отсортировать его. NB! Не удаляйте символ переноса строки”-\", если хотите сделать п.6. Проверьте длину строк. У вас есть пустые строки? Если есть, их можно удалить. 6*. Задание со звездочкой, выполнение опционально. Теперь надо разобраться с переносами строк, которые есть в печатных книгах, но нет в электронных текстах. Можно использовать цикл if: если предыдущая строка оканчивается на “-,” то создай новую строку, склеенную из предыдущей и этой. В противном случае, создай новую строку из предыдущей и этой, разделенную пробелом. Не забудьте обработать крайние значения (первая и последняя строки). Подготовим наши таблицы с фанфиками к обработке. sample %&gt;% print() ## # A tibble: 1,000 x 9 ## link title author_link author page fandom subtitle text likes ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 /read… Сгорая,… /authors/17… Mrs. L… 63 Неукр… Подкидыш &quot;Осенней… 27 ## 2 /read… Объятья… /authors/10… Wales 131 Неукр… &lt;NA&gt; &quot;На&lt;U+20… 864 ## 3 /read… Волосы … /authors/51… Nightm… 1 Неукр… Введение &quot;Миг зап… 47 ## 4 /read… Проверк… /authors/38… Cold-B… 52 Неукр… Семья &quot;На утро… 260 ## 5 /read… Поменяв… /authors/57… Aiky 4 Неукр… Глава 9 CQ… &quot;r / AmI… 282 ## 6 /read… Пепел и… /authors/39… Sh.R 79 Неукр… Вместо эпи… &quot;— Так, … 213 ## 7 /read… Собстве… /authors/14… Aquama… 86 Неукр… Глава 15. … &quot;Когда В… 587 ## 8 /read… И тёмны… /authors/45… Notyou… 96 Неукр… &lt;NA&gt; &quot;Что ест… 29 ## 9 /read… Я буду … /authors/54… Trisha… 20 Неукр… Часть 72 &quot;Сичень … 357 ## 10 /read… Мальчик… /authors/19… Lorie 33 Неукр… Гарри Потт… &quot;Планы Д… 3141 ## # … with 990 more rows Посмотрите на столбец authors_link. Нам же не нужен рудимент \" /authors/\", оставшийся после скрэппинга? Удалите его. ID автора гораздо легче использовать, чем его полный никнейм. Но у нас разное количество символов в ID. Нужно привести их к общей схеме, расширив строку до максимальной длины с помощью нулей, которые нужно вставить в начало строки. Аналогичные манипуляции предлагаю проделать с ID работы из графы “link” 4*. Задание со звездочкой, выполнение опционально. Посмотрите на графу subtitle. Очевидно, у нас скачались отдельные главы фанфиков как отдельные фанфики. Нехорошо. Но! У нас также есть сборники фичков, которые и должны рассматриваться как отдельные фанфики (см. п. 13). Чем они отличаются? Наверное, наличием символов \"/\", \"\\\" или \"|\" в графе subtitle. Попробуйте соединить те тексты фичков, у которых совпадает ID и отсутствуют вышеперечисленные символы в названии. Количество лайков и страниц указывается для всего фанфика, а не для каждой главы, так что их можете не трогать. 2.8 Sources https://www.gastonsanchez.com/Handling_and_Processing_Strings_in_R.pdf https://agricolamz.github.io/DS_for_DH/ "],["работа-с-регулярными-выражениями.html", "3 Работа с регулярными выражениями 3.1 Данные 3.2 Регулярные выражения 3.3 Символы 3.4 Классы символов 3.5 Символьные классы в POSIX 3.6 Дополнительные символьные классы 3.7 Метасимволы 3.8 Квантификаторы 3.9 Логические операции 3.10 Якори 3.11 Группы", " 3 Работа с регулярными выражениями 3.1 Данные Задача: импортируйте датасет data_ficbook_mass_effect.csv. Создайте копию, в которой не будет колонки text, либо сразу импортируйте без нее. library(data.table) mass_effect &lt;- fread(&#39;data_ficbook_mass_effect.csv&#39;) mass_effect_short &lt;- mass_effect[, .SD, .SDcols = -&#39;text&#39;] 3.2 Регулярные выражения Регулярные выражения (англ. Regular Expressions, regexps)- это специальный язык для описания шаблонов строк, который используется для поиска определенных строк, проверки их на соответствие какому-либо шаблону и другой подобной работы. Реализация регэкспов в разных языках программирования может различаться, в R используется расширенная версия регулярных выражений (ERE, стандарт POSIX 1003.2) с некоторыми собственными дополнениями, а так же Perl-совместимые регулярные выражения (PCRE 8.36). Согласно стандарту POSIX 1003.2, длина регулярных выражений не может превышать 256 байтов. Впрочем, как показывает практика, с таким ограничением мало кто сталкивается в своей работе. С регулярными выражениями есть, к сожалению, одна достаточно неприятная особенность - если выражение написано неправильно (в частности, при использовании метасимволов), то в результате, в зависимости от контекста использования, будет либо пропуск нужных элементов, либо просто отсутствие какого-либо эффекта. Поэтому есть смысл упрощать работу с регулярными выражениями, особенно если нет достаточного опыта их использования. Например, разбивать делать изменение части строки в несколько этапов, или же просто тестировать регулярные выражения небольшими блоками. 3.3 Символы В большинстве своем символы в регулярных выражениях обозначают сами себя, за некоторыми исключениями. Каждый символ в паттерне задает соответствие только одному символу в строке, поэтому в тех случаях, когда необходимо указать какой-то символ из определенного набора или указать, что какой-то символ повторяется некоторое количество раз подряд, следует использовать символьные классы или квантификаторы соответственно. Если в паттерне указать несколько символов, то поиск по строке будет произведен именно по такому сочетанию символов. Следует учитывать, что некоторые символы или сочетания символов могут быть проинтерпретированы либо как управляющие конструкции регулярных выражений и тогда потребуются дополнительные указания, как должны быть обработаны эти символы. Во-вторых, некоторые группы символов могут просто иметь дополнительные фиксированные значения. Так, для кодирования перехода на новую строку, табуляции и некоторых других непечатаемых символов используются определенные обозначения: \\n, \\r, \\t, \\v, \\f. Соответственно, если в строке встретится какое-то из этих сочетаний, то строка будет прочитана и обработана не как строка, содержащая символы обратного слеша и буквы, а как строка с спец.символом (в случае с табуляцией - \\t). Особенность парсера R в том, что символ \\ необходимо дополнительно экранировать, тоже обратным слешом. Это значит, что если в паттерне необходимо использовать \\v, то в паттерне регулярных выражений в R он указывается как \\\\v. Задача: у вас есть вектор vec &lt;- c('abd', 'bbc', 'ecd', 'ebbba'). С помощью функции gsub() замените все буквы a на символ _. Решение: vec &lt;- c(&#39;abd&#39;, &#39;bbc&#39;, &#39;ecd&#39;, &#39;eba&#39;) gsub(&#39;a&#39;, &#39;_&#39;, vec) ## [1] &quot;_bd&quot; &quot;bbc&quot; &quot;ecd&quot; &quot;eb_&quot; Задача: у вас есть вектор vec &lt;- c('abd', 'bbc', 'ecd', 'ebbba'). С помощью функции gsub() замените сочетание bb на символ _. Решение: vec &lt;- c(&#39;abd&#39;, &#39;bbc&#39;, &#39;ecd&#39;, &#39;ebbba&#39;) gsub(&#39;bb&#39;, &#39;_&#39;, vec) ## [1] &quot;abd&quot; &quot;_c&quot; &quot;ecd&quot; &quot;e_ba&quot; С помощью функций grep() / grepl() выберите и посчитайте, в каком количестве строк в колонке link встречается строка source=premium. При желании можете использовать близкие по смыслу функции пакета stringr (str_detect() / str_which()). Посчитайте, в каком количестве строк не встречается упоминание Тангейзера. Из ссылки на пользователя вида /authors/4039177 извлеките идентификатор пользователя. Запишите его в колонку author_id. Выберите текст пролога фанфика ‘Песнь Виктории’ и запишите в новый объект victory_song. Удалите символы переноса строки (чтобы их увидеть, выведите объект на печать). Задание повышенной сложности (как минимум, необходимо разобрать кейс): почистите текст так, чтобы 2063 года: «Покинуть из первых строчек превратилось в 2063 года:______«Покинуть. 3.4 Классы символов Задачи на поиск конкретного символа с помощью регулярных выражений встречаются, но обычно требуется большая гибкость поиска. Например, не конкретный символ или сочетание символов, а какой-либо символ из набора - знаки пунктуации или же цифры. Cамостоятельно указать какой-то набор символов можно с помощью квадратных скобок (квадратные скобки как метасимволы регулярных выражений и квадратные скобки в R - это разные конструкции). При этом можно либо просто перечислить все символы набора, либо, если они принадлежат какому-то известному множеству (например, цифры), то указать первый и последний элементы множества через знак дефиса (-). Также можно сочетать сокращенные формы записи наборов символов. Символы кириллического и латинского алфавитов - разные множества, точно также как строчные и прописные буквы. Внутри классов поведение метасимволов может различаться в зависимости от места их указания в наборе символов класса. Например, ^ первым символов в наборе символов задает логическое отрицание не из этих символов, и чтобы избежать такого поведения, знак ^ надо поставить на любое место кроме первого в цепочке. Знак ], если есть необходимость его вкючения в набор символов, наоборот, надо ставить первым в наборе, в противном случае он будет проинтерпретирован как завершение класса. Знак -, если указан не первым и не последним, интерпретируется как знак интервала в известном диапазоне символов (например, [0-9] означает от 0 до 9, а [09-] - символы 0, 9 и -) Из строки my_string удалите все цифры. my_string &lt;- &#39;D9586bNd879мрЯпп&#39; Из строки my_string &lt;- ‘D9586bNd879мрЯпп’ удалите все цифры и кириллические буквы. 3.5 Символьные классы в POSIX Стандарт POSIX 1003.2 поддерживает несколько определенных обозначения для часто используемых символьных классов: [:alnum:]: все буквы и цифры, сочетание символьных классов [:alpha:] и [:digit:]. [:alpha:]: буквы алфавита в обоих регистрах, для прописных и строчных букв есть отдельные символьные классы: [:lower:] и [:upper:]. [:punct:]: знаки пунктуации, !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~.. [:digit:]: арабские цифры 0123456789. [:xdigit:]: цифры в шестнадцатеричном формате, 0123456789ABCDEFabcdef. [:graph:]: графические знаки, объединенный класс, состоящий из классов [:alnum:] и [:punct:]. [:print:]: печатаемые знаки, класс [:graph:], дополненный пробелом. [:blank:]: непечатаемые символы (пробел, знак табуляции, в зависимости от локали - неразрывный пробел и возможные другие непечатаемые символы). [:cntrl:]: управляющие символы (в таблицах символов ANSCII коды 000-031 и 121 в десятичной, 000-037 и 177 в восьмеричной системе, 000-07F в шестнадцатеричной системах счислений) [:space:]: некоторые управляющие символы, которые используются для создания разрывов между символами - пробел, переход на новую строку, возврат каретки, перевод страницы и т.д. В зависимости от локали может содержать дополнительные знаки. При указании символьного класса с помощью его имени надо помнить, что обозначение класса также заключается в []. То есть, вместо [:digit:] (обозначение класса) надо использовать [[:digit:]] (указание символьного класса в рег.выражении): gsub(&#39;[[:digit:]]&#39;, &#39;&#39;, my_string) ## [1] &quot;DbNdмрЯпп&quot; 3.6 Дополнительные символьные классы Помимо обозначений символьных классов, которые поддерживаются стандартом POSIX, также в R реализован ряд собственных символьных классов, которые, как правило, обозначают наиболее часто используемые комбинации: \\\\s - пробел \\\\S: все знаки, кроме пробела. Аналогично [^[:space:]] или [^\\\\s] \\\\d: цифры, аналогично [0-9] \\\\D: не цифры, обратно \\\\d, аналогично [^0-9] \\\\w: символы, которые используются в письме, аналогично [A-z0-9_] \\\\W: обратный \\\\w набор, символы, которые не используются в письме Из victory_song удалите все знаки препинания (замените на пробел). Попробуйте это сделать как просто с помощью классов символов, так и с помощью POSIX-классов. Задание повышенной сложности: выберите из victory_song все слова, в которых встречаются заглавные буквы. 3.7 Метасимволы Ряд символов имеет дополнительное значение - эти символы используются не только сами по себе, но и как определенные конструкции языка регулярных выражений. В частности, это символ [, который используется для создания произвольного символьного класса. Полный список выглядит следующим образом: .: подстановочный знак (wildcard), используется в тех случаях, когда необходимо указать, что на этом месте может быть любой знак \\: используется для экранирования метасимволов | : логический оператор или ( и ): используются для указания групп символов [: вместе с ] используется для указания символьных классов ^: якорь, указывающий на начало строки, а так же логический оператор отрицания, используемый в символьных классах $: якорь, указывающий на конец строки *, + и ? - квантификаторы, указывающие, что предыдущий символ или группа символов могут или должны повториться некоторое количество раз {: вместе с } исползуется как квантификатор, указывающий конкретное количество повторений предыдущего символа или группы символов &lt; и &gt;: используется в Perl-совместимых регулярных выражениях Для того, чтобы эти метасимволы воспринимались не как элементы языка регулярных выражений, а как есть, их необходимо экранировать двумя символами \\\\. Необходимость в двух символах \\\\ для экранирования возникает из-за того, что строковая запись регулярного выражения в R и собственно выражение на языке регулярных выражений несколько различаются. Удалите из строки metachara.cters символы . и . 3.8 Квантификаторы Для того, чтобы в паттерне указать, что какой-то символ или группа символов может повторяться, используют специальные управляющие знаки - квантификаторы: ?: предыдущий символ или группа символов в паттерне может встречаться 0 или 1 раз. Также вместе с другими квантификаторами используется для нежадного поиска. *: предыдущий символ или группа символов в паттерне может встречаться 0 или больше раз. +: предыдущий символ или группа символов в паттерне может встречаться 1 или больше раз. {n}: предыдущий символ или группа символов может встречаться в паттерно строго n раз. {n,}: предыдущий символ или группа символов может встречаться в паттерно n и более раз. Конструкции {0,} и {1,} тождественны * и + соответственно. {n,m}: предыдущий символ или группа символов может встречаться в паттерно n раз, но не более, чем m раз. Конструкции {0,1} и ? тождественны. Простейший пример использования квантификаторов - когда надо обработать какой-то символ, который встречается несколько раз. Например, скрыть последние четыре цифры в номере телефона: phone_number &lt;- &#39;my phone number: +7-929-138-5896&#39; gsub(&#39;[0-9]{4}&#39;, &#39;XXXX&#39;, phone_number) ## [1] &quot;my phone number: +7-929-138-XXXX&quot; В объекте victory_song замените повторяющиеся пробелы на один пробел. 3.9 Логические операции В регулярных выражениях логические операции представлены в достаточно ограниченном виде, можно даже сказать, крайне бедно. Наиболее очевидная из существующих операции - это ИЛИ, когда надо задать несколько вариантов комбинаций символов. В частности, это крайне полезный инструмент для фильтрации вектора строковых значений по определенному критерию. Например, регулярными выражениями с логическим оператором можно просто выделить из списка логов те файлы, которые были созданы в 2015-2016 годах: models &lt;- c(&#39;log_2014.csv&#39;, &#39;log_2015.csv&#39;, &#39;log_2016.csv&#39;, &#39;log_2017.csv&#39;, &#39;log_2018.csv&#39;) models[grep(&#39;2015|2016&#39;, models)] ## [1] &quot;log_2015.csv&quot; &quot;log_2016.csv&quot; Второй логический оператор - ^, используется в тех случаях, когда надо исключить символы определенного класса. Следует помнить, что ^ используется в этом значении сугубо внутри [], в противном случае будет интерпретироваться в другом значении. # заменяем на &#39;_&#39; любой из символов d, e, f gsub(&#39;[def]&#39;, &#39;_&#39;, &#39;fadbcdefghe&#39;) ## [1] &quot;_a_bc___gh_&quot; # заменяем на &#39;_&#39; все, кроме символов d, e, f gsub(&#39;[^def]&#39;, &#39;_&#39;, &#39;fadbcdefghe&#39;) ## [1] &quot;f_d__def__e&quot; 3.10 Якори Якори используются для обозначения, что сочетание символов в паттерне обязательно должно начинать или завершать строку. Также есть якори, которые маркируют начало или конец не строки, а слова, однако само определение слова зависит от используемой локали. В R используются следующие якори: ^ и $: начало и конец строки соответственно \\\\&lt; и \\\\&gt;: начало и конец слова \\\\b: пустая строка или края слова \\\\B: не край слова Задание: удалите пробелы в начале и в конце victory_song. Используйте логические операторы Выберите все фанфики, у которых имя автора начинается с заглавной латинской буквы. Используйте для этого таблицу без текста фанфиков (тексты очень большие, утяжеляют работу с данными). Выберите с помощью регулярных выражений все фанфики, в который название состоит из одного слова. Используйте регулярные выражения, хотя, конечно, есть и более простые решения. 3.11 Группы Квантификаторы обычно работают относительно предыдущего указанного символа. Однако нередко возникают ситуации, когда требуется провести какую-то операцию над определенной группой символов. В таких случаях используют знаки группировки - ( и ). Набор символов и/или выражение, заключенные в скобки, будут восприниматься как неразрывная последовательность символов, и обрабатываться соответствующим образом. Например, если мы хотим удалить из строки строго двукратное повторение группы символов: my_string &lt;- c(&#39;abRababL&#39;) # пробуем удалить пару символов без указания группы gsub(&#39;ab&#39;, &#39;_DELETED_&#39;, my_string) ## [1] &quot;_DELETED_R_DELETED__DELETED_L&quot; # группируем символы с помощью () gsub(&#39;(ab){2}&#39;, &#39;_DELETED_&#39;, my_string) ## [1] &quot;abR_DELETED_L&quot; При необходимости всю обрабатываемую строку можно, с помощью символьных классов, групп и прочих инструментов регулярных выражений, представить в паттерне. При подобном представлении группы нумеруются и может быть обработана конкретная группа символов, вызванная по номеру. Номера групп обозначаются как \\\\1-\\\\9. Например: gsub(&#39;([a-z]*)-([0-9]*)&#39;, &#39;\\\\1&#39;, &#39;abra-9998&#39;) ## [1] &quot;abra&quot; gsub(&#39;([a-z]*)-([0-9]*)&#39;, &#39;\\\\2&#39;, &#39;abra-9998&#39;) ## [1] &quot;9998&quot; Удалите из названия фанфика текст в скобках, если он идет после собственно названия, используя механизм групп. Например, из Aidu (фанфик переписан) надо сделать Aidu. Проверьте, как выражение работает на строке Открытое письмо от Жорика (он же дредноут «Давящий») автору Архин. "],["сбор-данных-из-интернета-rvest.html", "4 Сбор данных из интернета: rvest 4.1 Введение 4.2 Работа с пакетом rvest 4.3 Использование циклов 4.4 Обкачивание нескольких страниц", " 4 Сбор данных из интернета: rvest library(tidyverse) Достаточно часто данные не ходят упакованные в готовые файлы .csv или .json. Иногда данные лежат в открытом доступе на какой-нибудь странице в интернете. А иногда никто и не думал, что что-то станет данными: заголовки и тексты новостей, комментарии, твиты и т. п. В этом разделе мы обсудим основы извлечения данных из вебстраниц. 4.1 Введение Любая html-документ — это обычный xml файл, т. е. такой иерархически устроенный тип данных, где у каждого узла (кроме корневого) есть родительский узел и могут быть дочерние узлы и дополнительные атрибуты. Обычно самый верхний узел называется html, который имеет два дочерних узла head и body. Каждый html-документ является инструкцией для браузера, в которой говориться что и в каком порядке нужно отображать, но одновременно эта инструкция является кодом, который мы можем посмотреть. В большинстве браузеров это можно сделать при помощи горячих клавиш Ctrl+U, в Apple Safari — Cmd+Option+U. Кроме того есть режим разработчика, который позволяет делать много всего, в том числе наводить на какой-то объект в браузере и узнавать какой фрагмент кода ему соответствует (этот режим можно вызвать, нажав F12 или Ctrl+Shift+I, в Apple Safari вроде нет горячих клавиш и нужно вызывать как-то из меню). Большинство узлов html-документа состоят из тег узла, например, p значения узла, например, Жили-были три медведя. id (уникальные объекты в html-документе), class (неуникальные объекты в html-документе) и другием атрибуты узла Например: &lt;p class=&quot;story&quot; some_atribute = 42&gt;Жили-были три медведя.&lt;/p&gt; Некоторые html-документ не являются статическими и изменяются после того, как страница была открыта при помощи JavaScript’а. Это динамичность может быть скрытой, когда пользователь лишь видит, как открывается страница, а иногда может быть завязана на некоторые действия пользователя. Информацию со статических страниц собирать достаточно просто и для этого нам хватит пакета rvest. C динамическими сайтами все иногда несколько сложнее. Иногда на динамических страницах можно отследить источник данных, посмотрев вкладку Network в режиме разработчика (ведь откуда-то эти данные появляются в браузере, правда?). Иногда необходимо делать POST и GET запросы, хранить cookies, и т. п. — все это можно сделать при помощи пакета httr, а в самых сложных случаях (когда JavaScript JavaScript погоняет) поможет пакет RSelenium. html-тэгов очень много. Нам понадобятся: h1, h2, h3… – заголовки разного уровня p – абзац текста a – ссылка div – блок страницы (от слова division) Остальное смотрите, например, здесь. 4.2 Работа с пакетом rvest Пакет rvest позволяет скачивать страницы и потом их обрабатывать. Включим библиотеку: library(rvest) 4.2.1 Простой случай В качестве примера рассмотрим раздел популярное сайта &lt;ficbook.net&gt;: source &lt;- read_html(&quot;https://ficbook.net/popular&quot;) Объект source является списком, который содержит html-страницу. Давайте для начала выгрузим заголовок первого уровня. Функция html_nodes() позволяет вычленить исключительно узлы с каким-то тегом из всего xml-файла. source %&gt;% html_nodes(&quot;h1&quot;) {xml_nodeset (1)} [1] &lt;h1&gt;\\n Популярные фанфики и ориджиналы\\n &lt;/h1&gt; Как видно, функция вовзращает целый узел со всеми тегами. Давайте допустим, что мы хотем скачать все заголовки новостей, т. е. нам нужны значения всех узло h3. source %&gt;% html_nodes(&quot;h3&quot;) {xml_nodeset (51)} [1] &lt;h3&gt;\\n \\n ... [2] &lt;h3&gt;\\n \\n ... [3] &lt;h3&gt;\\n \\n ... [4] &lt;h3&gt;\\n \\n ... [5] &lt;h3&gt;\\n \\n ... [6] &lt;h3&gt;\\n \\n ... [7] &lt;h3&gt;\\n \\n ... [8] &lt;h3&gt;\\n \\n ... [9] &lt;h3&gt;\\n \\n ... [10] &lt;h3&gt;\\n \\n ... [11] &lt;h3&gt;\\n \\n ... [12] &lt;h3&gt;\\n \\n ... [13] &lt;h3&gt;\\n \\n ... [14] &lt;h3&gt;\\n \\n ... [15] &lt;h3&gt;\\n \\n ... [16] &lt;h3&gt;\\n \\n ... [17] &lt;h3&gt;\\n \\n ... [18] &lt;h3&gt;\\n \\n ... [19] &lt;h3&gt;\\n \\n ... [20] &lt;h3&gt;\\n \\n ... ... Ничего не видно. Это связано с тем, что на данном сайте в заголовки добавили много всего: Теперь если мы хотим обратиться к значениям этих узлов, мы можем использовать функцию html_text(): source %&gt;% html_nodes(&quot;h3&quot;) %&gt;% html_text() [1] &quot;\\n \\n \\n \\n \\n\\n Yellow\\n 40324&quot; [2] &quot;\\n \\n \\n \\n \\n\\n Сметана\\n 30142&quot; [3] &quot;\\n \\n \\n \\n \\n\\n Лисамайн\\n 26102&quot; [4] &quot;\\n \\n \\n \\n \\n\\n В Котисаари сегодня осень\\n 26232&quot; [5] &quot;\\n \\n \\n \\n \\n\\n Снежный принц для Владыки\\n 18602&quot; [6] &quot;\\n \\n \\n \\n \\n\\n Weihnachten\\n 21621&quot; [7] &quot;\\n \\n \\n \\n \\n\\n Три месяца, ноль дней и ноль часов\\n 1647&quot; [8] &quot;\\n \\n \\n \\n \\n\\n shadow moses \\n 1621&quot; [9] &quot;\\n \\n \\n \\n \\n\\n feels like home\\n 21861&quot; [10] &quot;\\n \\n \\n \\n \\n\\n К вопросу об отношениях\\n 20741&quot; [11] &quot;\\n \\n \\n \\n \\n\\n Ban Crann\\n 17381&quot; [12] &quot;\\n \\n \\n \\n \\n\\n Светлячок\\n 12921&quot; [13] &quot;\\n \\n \\n \\n \\n\\n Вжик-вжик\\n 19071&quot; [14] &quot;\\n \\n \\n \\n \\n\\n Миша и опер Медведев\\n 129613&quot; [15] &quot;\\n \\n \\n \\n \\n\\n Saint Allan&#39;s Night\\n 14552&quot; [16] &quot;\\n \\n \\n \\n \\n\\n the union is our only strength\\n 1180&quot; [17] &quot;\\n \\n \\n \\n \\n\\n Jamais vu\\n 312214&quot; [18] &quot;\\n \\n \\n \\n \\n\\n Волчье\\n 15722&quot; [19] &quot;\\n \\n \\n \\n \\n\\n Deadlock\\n 698954&quot; [20] &quot;\\n \\n \\n \\n \\n\\n К алтарю \\n 2120&quot; [21] &quot;\\n \\n \\n \\n \\n\\n soon, he is going to be my lover\\n 1072&quot; [22] &quot;\\n \\n \\n \\n \\n\\n Район спальный \\n 10902&quot; [23] &quot;\\n \\n \\n \\n \\n\\n С любовью, розовый\\n 10412&quot; [24] &quot;\\n \\n \\n \\n \\n\\n Гранатовые соски Чон Чонгука\\n 1742&quot; [25] &quot;\\n \\n \\n \\n \\n\\n Кабинет 69.\\n 2745&quot; [26] &quot;\\n \\n \\n \\n \\n\\n У меня на тебя аллергия \\n 970&quot; [27] &quot;\\n \\n \\n \\n \\n\\n Знание — сила!\\n 421220&quot; [28] &quot;\\n \\n \\n \\n \\n\\n Привет, Джимми!\\n 8462&quot; [29] &quot;\\n \\n \\n \\n \\n\\n fuck me, bestie\\n 956&quot; [30] &quot;\\n \\n \\n \\n \\n\\n Я больше не облажаюсь, старлей...\\n 10912&quot; [31] &quot;\\n \\n \\n \\n \\n\\n Хочу детей от друга\\n 18111&quot; [32] &quot;\\n \\n \\n \\n \\n\\n Выбор Тристана\\n 23716&quot; [33] &quot;\\n \\n \\n \\n \\n\\n Алаймент\\n 445266&quot; [34] &quot;\\n \\n \\n \\n \\n\\n Братья\\n 319611&quot; [35] &quot;\\n \\n \\n \\n \\n\\n Невинный для Ночного господина\\n 9304&quot; [36] &quot;\\n \\n \\n \\n \\n\\n at the end of everything\\n 658&quot; [37] &quot;\\n \\n \\n \\n \\n\\n Лесная ягода \\n 1987&quot; [38] &quot;\\n \\n \\n \\n \\n\\n Предсказанному верить, или Чему быть, того не миновать\\n 6132&quot; [39] &quot;\\n \\n \\n \\n \\n\\n Истинность солнца\\n 17135&quot; [40] &quot;\\n \\n \\n \\n \\n\\n Не зная, как, когда или откуда\\n 759&quot; [41] &quot;\\n \\n \\n \\n \\n\\n my furry\\n 890&quot; [42] &quot;\\n \\n \\n \\n \\n\\n Принц на белом ковре \\n 6012&quot; [43] &quot;\\n \\n \\n \\n \\n\\n r/relationships\\n 9651&quot; [44] &quot;\\n \\n \\n \\n \\n\\n Но... я же Питер Паркер!\\n 615814&quot; [45] &quot;\\n \\n \\n \\n \\n\\n Молодой Мороз\\n 5673&quot; [46] &quot;\\n \\n \\n \\n \\n\\n Что не так с вашей Вселенной? \\n 544&quot; [47] &quot;\\n \\n \\n \\n \\n\\n Креативщик\\n 18401&quot; [48] &quot;\\n \\n \\n \\n \\n\\n Stuck on you\\n 7071&quot; [49] &quot;\\n \\n \\n \\n \\n\\n Бывшие\\n 22792&quot; [50] &quot;\\n \\n \\n \\n \\n\\n На Марсе классно\\n 5181&quot; [51] &quot;Войдите в аккаунт&quot; Стоит почистить: source %&gt;% html_nodes(&quot;h3&quot;) %&gt;% html_text() %&gt;% str_replace_all(&quot; {1,}&quot;, &quot; &quot;) [1] &quot;\\n \\n \\n \\n \\n\\n Yellow\\n 40324&quot; [2] &quot;\\n \\n \\n \\n \\n\\n Сметана\\n 30142&quot; [3] &quot;\\n \\n \\n \\n \\n\\n Лисамайн\\n 26102&quot; [4] &quot;\\n \\n \\n \\n \\n\\n В Котисаари сегодня осень\\n 26232&quot; [5] &quot;\\n \\n \\n \\n \\n\\n Снежный принц для Владыки\\n 18602&quot; [6] &quot;\\n \\n \\n \\n \\n\\n Weihnachten\\n 21621&quot; [7] &quot;\\n \\n \\n \\n \\n\\n Три месяца, ноль дней и ноль часов\\n 1647&quot; [8] &quot;\\n \\n \\n \\n \\n\\n shadow moses \\n 1621&quot; [9] &quot;\\n \\n \\n \\n \\n\\n feels like home\\n 21861&quot; [10] &quot;\\n \\n \\n \\n \\n\\n К вопросу об отношениях\\n 20741&quot; [11] &quot;\\n \\n \\n \\n \\n\\n Ban Crann\\n 17381&quot; [12] &quot;\\n \\n \\n \\n \\n\\n Светлячок\\n 12921&quot; [13] &quot;\\n \\n \\n \\n \\n\\n Вжик-вжик\\n 19071&quot; [14] &quot;\\n \\n \\n \\n \\n\\n Миша и опер Медведев\\n 129613&quot; [15] &quot;\\n \\n \\n \\n \\n\\n Saint Allan&#39;s Night\\n 14552&quot; [16] &quot;\\n \\n \\n \\n \\n\\n the union is our only strength\\n 1180&quot; [17] &quot;\\n \\n \\n \\n \\n\\n Jamais vu\\n 312214&quot; [18] &quot;\\n \\n \\n \\n \\n\\n Волчье\\n 15722&quot; [19] &quot;\\n \\n \\n \\n \\n\\n Deadlock\\n 698954&quot; [20] &quot;\\n \\n \\n \\n \\n\\n К алтарю \\n 2120&quot; [21] &quot;\\n \\n \\n \\n \\n\\n soon, he is going to be my lover\\n 1072&quot; [22] &quot;\\n \\n \\n \\n \\n\\n Район спальный \\n 10902&quot; [23] &quot;\\n \\n \\n \\n \\n\\n С любовью, розовый\\n 10412&quot; [24] &quot;\\n \\n \\n \\n \\n\\n Гранатовые соски Чон Чонгука\\n 1742&quot; [25] &quot;\\n \\n \\n \\n \\n\\n Кабинет 69.\\n 2745&quot; [26] &quot;\\n \\n \\n \\n \\n\\n У меня на тебя аллергия \\n 970&quot; [27] &quot;\\n \\n \\n \\n \\n\\n Знание — сила!\\n 421220&quot; [28] &quot;\\n \\n \\n \\n \\n\\n Привет, Джимми!\\n 8462&quot; [29] &quot;\\n \\n \\n \\n \\n\\n fuck me, bestie\\n 956&quot; [30] &quot;\\n \\n \\n \\n \\n\\n Я больше не облажаюсь, старлей...\\n 10912&quot; [31] &quot;\\n \\n \\n \\n \\n\\n Хочу детей от друга\\n 18111&quot; [32] &quot;\\n \\n \\n \\n \\n\\n Выбор Тристана\\n 23716&quot; [33] &quot;\\n \\n \\n \\n \\n\\n Алаймент\\n 445266&quot; [34] &quot;\\n \\n \\n \\n \\n\\n Братья\\n 319611&quot; [35] &quot;\\n \\n \\n \\n \\n\\n Невинный для Ночного господина\\n 9304&quot; [36] &quot;\\n \\n \\n \\n \\n\\n at the end of everything\\n 658&quot; [37] &quot;\\n \\n \\n \\n \\n\\n Лесная ягода \\n 1987&quot; [38] &quot;\\n \\n \\n \\n \\n\\n Предсказанному верить, или Чему быть, того не миновать\\n 6132&quot; [39] &quot;\\n \\n \\n \\n \\n\\n Истинность солнца\\n 17135&quot; [40] &quot;\\n \\n \\n \\n \\n\\n Не зная, как, когда или откуда\\n 759&quot; [41] &quot;\\n \\n \\n \\n \\n\\n my furry\\n 890&quot; [42] &quot;\\n \\n \\n \\n \\n\\n Принц на белом ковре \\n 6012&quot; [43] &quot;\\n \\n \\n \\n \\n\\n r/relationships\\n 9651&quot; [44] &quot;\\n \\n \\n \\n \\n\\n Но... я же Питер Паркер!\\n 615814&quot; [45] &quot;\\n \\n \\n \\n \\n\\n Молодой Мороз\\n 5673&quot; [46] &quot;\\n \\n \\n \\n \\n\\n Что не так с вашей Вселенной? \\n 544&quot; [47] &quot;\\n \\n \\n \\n \\n\\n Креативщик\\n 18401&quot; [48] &quot;\\n \\n \\n \\n \\n\\n Stuck on you\\n 7071&quot; [49] &quot;\\n \\n \\n \\n \\n\\n Бывшие\\n 22792&quot; [50] &quot;\\n \\n \\n \\n \\n\\n На Марсе классно\\n 5181&quot; [51] &quot;Войдите в аккаунт&quot; Ага теперь видно, что к нам в заголовки затесалось предложение войти в аккаунт. Пока просто удалим. source %&gt;% html_nodes(&quot;h3&quot;) %&gt;% html_text() %&gt;% str_replace_all(&quot; {1,}&quot;, &quot; &quot;) %&gt;% str_remove_all(&quot;\\n&quot;) %&gt;% # удалим все \\n str_remove_all(&quot;^ {1,}&quot;) # удалим все пробелы в начале строки [1] &quot;Yellow 40324&quot; [2] &quot;Сметана 30142&quot; [3] &quot;Лисамайн 26102&quot; [4] &quot;В Котисаари сегодня осень 26232&quot; [5] &quot;Снежный принц для Владыки 18602&quot; [6] &quot;Weihnachten 21621&quot; [7] &quot;Три месяца, ноль дней и ноль часов 1647&quot; [8] &quot;shadow moses 1621&quot; [9] &quot;feels like home 21861&quot; [10] &quot;К вопросу об отношениях 20741&quot; [11] &quot;Ban Crann 17381&quot; [12] &quot;Светлячок 12921&quot; [13] &quot;Вжик-вжик 19071&quot; [14] &quot;Миша и опер Медведев 129613&quot; [15] &quot;Saint Allan&#39;s Night 14552&quot; [16] &quot;the union is our only strength 1180&quot; [17] &quot;Jamais vu 312214&quot; [18] &quot;Волчье 15722&quot; [19] &quot;Deadlock 698954&quot; [20] &quot;К алтарю 2120&quot; [21] &quot;soon, he is going to be my lover 1072&quot; [22] &quot;Район спальный 10902&quot; [23] &quot;С любовью, розовый 10412&quot; [24] &quot;Гранатовые соски Чон Чонгука 1742&quot; [25] &quot;Кабинет 69. 2745&quot; [26] &quot;У меня на тебя аллергия 970&quot; [27] &quot;Знание — сила! 421220&quot; [28] &quot;Привет, Джимми! 8462&quot; [29] &quot;fuck me, bestie 956&quot; [30] &quot;Я больше не облажаюсь, старлей... 10912&quot; [31] &quot;Хочу детей от друга 18111&quot; [32] &quot;Выбор Тристана 23716&quot; [33] &quot;Алаймент 445266&quot; [34] &quot;Братья 319611&quot; [35] &quot;Невинный для Ночного господина 9304&quot; [36] &quot;at the end of everything 658&quot; [37] &quot;Лесная ягода 1987&quot; [38] &quot;Предсказанному верить, или Чему быть, того не миновать 6132&quot; [39] &quot;Истинность солнца 17135&quot; [40] &quot;Не зная, как, когда или откуда 759&quot; [41] &quot;my furry 890&quot; [42] &quot;Принц на белом ковре 6012&quot; [43] &quot;r/relationships 9651&quot; [44] &quot;Но... я же Питер Паркер! 615814&quot; [45] &quot;Молодой Мороз 5673&quot; [46] &quot;Что не так с вашей Вселенной? 544&quot; [47] &quot;Креативщик 18401&quot; [48] &quot;Stuck on you 7071&quot; [49] &quot;Бывшие 22792&quot; [50] &quot;На Марсе классно 5181&quot; [51] &quot;Войдите в аккаунт&quot; Теперь попробуем сделать таблицу и уберем цифры в конце: source %&gt;% html_nodes(&quot;h3&quot;) %&gt;% html_text() %&gt;% str_replace_all(&quot; {1,}&quot;, &quot; &quot;) %&gt;% str_remove_all(&quot;\\n&quot;) %&gt;% str_remove_all(&quot;^ {1,}&quot;) %&gt;% enframe() %&gt;% # превратим в таблицу slice(-n()) %&gt;% # удалим последнюю строчку mutate(numbers = str_extract(value, &quot;\\\\d*$&quot;), # выделим код value = str_remove(value, str_c(&quot; {1,}&quot;, numbers))) %&gt;% # удалим код и пробел select(-numbers) -&gt; # удалим столбец pop_fan_fiction pop_fan_fiction Каждый заголовок содержит ссылку на страницу фанфика, как бы ее добыть? Ссылка на самом деле в теге , так что теперь нам нужны такие &lt;a&gt;, которые находятся внутри &lt;h3&gt;: source %&gt;% html_nodes(&quot;h3 a&quot;) {xml_nodeset (50)} [1] &lt;a href=&quot;/readfic/10429398&quot; class=&quot;visit-link&quot;&gt;Yellow&lt;/a&gt; [2] &lt;a href=&quot;/readfic/10357485&quot; class=&quot;visit-link&quot;&gt;Сметана&lt;/a&gt; [3] &lt;a href=&quot;/readfic/10019420&quot; class=&quot;visit-link&quot;&gt;Лисамайн&lt;/a&gt; [4] &lt;a href=&quot;/readfic/10019135&quot; class=&quot;visit-link&quot;&gt;В Котисаари сегодня осень ... [5] &lt;a href=&quot;/readfic/10395350&quot; class=&quot;visit-link&quot;&gt;Снежный принц для Владыки ... [6] &lt;a href=&quot;/readfic/9997807&quot; class=&quot;visit-link&quot;&gt;Weihnachten&lt;/a&gt; [7] &lt;a href=&quot;/readfic/10421614&quot; class=&quot;visit-link&quot;&gt;Три месяца, ноль дней и н ... [8] &lt;a href=&quot;/readfic/10406612&quot; class=&quot;visit-link&quot;&gt;shadow moses &lt;/a&gt; [9] &lt;a href=&quot;/readfic/10408684&quot; class=&quot;visit-link&quot;&gt;feels like home&lt;/a&gt; [10] &lt;a href=&quot;/readfic/10415930&quot; class=&quot;visit-link&quot;&gt;К вопросу об отношениях&lt;/a&gt; [11] &lt;a href=&quot;/readfic/10033794&quot; class=&quot;visit-link&quot;&gt;Ban Crann&lt;/a&gt; [12] &lt;a href=&quot;/readfic/10371908&quot; class=&quot;visit-link&quot;&gt;Светлячок&lt;/a&gt; [13] &lt;a href=&quot;/readfic/10019753&quot; class=&quot;visit-link&quot;&gt;Вжик-вжик&lt;/a&gt; [14] &lt;a href=&quot;/readfic/10416997&quot; class=&quot;visit-link&quot;&gt;Миша и опер Медведев&lt;/a&gt; [15] &lt;a href=&quot;/readfic/10016266&quot; class=&quot;visit-link&quot;&gt;Saint Allan&#39;s Night&lt;/a&gt; [16] &lt;a href=&quot;/readfic/10431022&quot; class=&quot;visit-link&quot;&gt;the union is our only str ... [17] &lt;a href=&quot;/readfic/10395456&quot; class=&quot;visit-link&quot;&gt;Jamais vu&lt;/a&gt; [18] &lt;a href=&quot;/readfic/10037569&quot; class=&quot;visit-link&quot;&gt;Волчье&lt;/a&gt; [19] &lt;a href=&quot;/readfic/9812943&quot; class=&quot;visit-link&quot;&gt;Deadlock&lt;/a&gt; [20] &lt;a href=&quot;/readfic/10397610&quot; class=&quot;visit-link&quot;&gt;К алтарю &lt;/a&gt; ... Так как ссылка находиться не в тексте, а в атрибуте нужна функция html_attr(): source %&gt;% html_nodes(&quot;h3 a&quot;) %&gt;% html_attr(&quot;href&quot;) [1] &quot;/readfic/10429398&quot; &quot;/readfic/10357485&quot; &quot;/readfic/10019420&quot; [4] &quot;/readfic/10019135&quot; &quot;/readfic/10395350&quot; &quot;/readfic/9997807&quot; [7] &quot;/readfic/10421614&quot; &quot;/readfic/10406612&quot; &quot;/readfic/10408684&quot; [10] &quot;/readfic/10415930&quot; &quot;/readfic/10033794&quot; &quot;/readfic/10371908&quot; [13] &quot;/readfic/10019753&quot; &quot;/readfic/10416997&quot; &quot;/readfic/10016266&quot; [16] &quot;/readfic/10431022&quot; &quot;/readfic/10395456&quot; &quot;/readfic/10037569&quot; [19] &quot;/readfic/9812943&quot; &quot;/readfic/10397610&quot; &quot;/readfic/9570998&quot; [22] &quot;/readfic/10411907&quot; &quot;/readfic/10402262&quot; &quot;/readfic/10407954&quot; [25] &quot;/readfic/10309689&quot; &quot;/readfic/10416707&quot; &quot;/readfic/10371922&quot; [28] &quot;/readfic/10161264&quot; &quot;/readfic/10388478&quot; &quot;/readfic/10402435&quot; [31] &quot;/readfic/10379341&quot; &quot;/readfic/10329650&quot; &quot;/readfic/10112253&quot; [34] &quot;/readfic/10326638&quot; &quot;/readfic/10420671&quot; &quot;/readfic/10432311&quot; [37] &quot;/readfic/9773287&quot; &quot;/readfic/10418910&quot; &quot;/readfic/10354281&quot; [40] &quot;/readfic/10399219&quot; &quot;/readfic/10396570&quot; &quot;/readfic/10381686&quot; [43] &quot;/readfic/9974478&quot; &quot;/readfic/7861843&quot; &quot;/readfic/10034120&quot; [46] &quot;/readfic/10368424&quot; &quot;/readfic/10404116&quot; &quot;/readfic/10413770&quot; [49] &quot;/readfic/9178422&quot; &quot;/readfic/10420432&quot; Теперь мы можем сохранить это в переменную нашей таблицы pop_fan_fiction: source %&gt;% html_nodes(&quot;h3 a&quot;) %&gt;% html_attr(&quot;href&quot;) -&gt; pop_fan_fiction$link pop_fan_fiction Теперь, если мы соединим кусочек в графе link и https://ficbook.net, то мы получим ссылку на текст/оглавления фанфика. Добавьте к таблице столбец с количеством лайков. Попробуем обкачать авторов и ссылки на их страницы и добавить их к таблице. Если мы присмотримся, то авторы находятся в теге &lt;div&gt;. Однако это очень популярный тэг, и в нем может быть все, что угодно, так что добавим еще тегов, чтобы указать путь точнее: [1] &quot;Канда Лотос&quot; &quot;Канда Лотос&quot; [3] &quot;Канда Лотос&quot; &quot;Канда Лотос&quot; [5] &quot;chate&quot; &quot;Канда Лотос&quot; [7] &quot;Франк пишет&quot; &quot;magnus bane&quot; [9] &quot;international playgirl&quot; &quot;лунный мечтатель полтергейста&quot; [11] &quot;Канда Лотос&quot; &quot;Pak Yeon Hee&quot; [13] &quot;Канда Лотос&quot; &quot;YKET&quot; [15] &quot;Канда Лотос&quot; &quot;Чайка_Лу&quot; [17] &quot;rikookie&quot; &quot;Канда Лотос&quot; [19] &quot;rikookie&quot; &quot;Франк пишет&quot; [21] &quot;Чайка_Лу&quot; &quot;Deus Rex&quot; [23] &quot;magnus bane&quot; &quot;Франк пишет&quot; [25] &quot;Anna Moss&quot; &quot;К.О.В.Ш.&quot; [27] &quot;Aurit&quot; &quot;Аргус Филченков&quot; [29] &quot;Eva_Grey&quot; &quot;Shifer dark&quot; [31] &quot;SugarSyrup&quot; &quot;голубая радуга&quot; [33] &quot;Rakot&quot; &quot;Pak Yeon Hee&quot; [35] &quot;Это Хорошо&quot; &quot;Чайка_Лу&quot; [37] &quot;minimoninam&quot; &quot;Fereht&quot; [39] &quot;magnus bane&quot; &quot;Vi Ewaz&quot; [41] &quot;sarahyyy&quot; &quot;HaruHarada&quot; [43] &quot;SGI&quot; &quot;hartwig_n&quot; [45] &quot;vespertineflora&quot; &quot;Drizzt&quot; [47] &quot;YKET&quot; &quot;Sivilla&quot; [49] &quot;Pink_bra&quot; &quot;varnish&quot; [51] &quot;younghosie&quot; &quot;Kiuochi&quot; Все хорошо, но получилось 52 строчки, а в нашем pop_fan_fiction лишь 50 строчек. Это связано с тем, что у некоторых фанфиков несколько авторов. К счастью это можно “вылечить” посмотрев на ссылки: source %&gt;% html_nodes(&quot;div span a&quot;) %&gt;% html_attr(&quot;href&quot;) -&gt; author_links author_links [1] &quot;/authors/1819996&quot; [2] &quot;/authors/1819996&quot; [3] &quot;/authors/1819996&quot; [4] &quot;/authors/1819996&quot; [5] &quot;/authors/45010&quot; [6] &quot;/authors/1819996&quot; [7] &quot;/authors/4371126&quot; [8] &quot;/authors/211970&quot; [9] &quot;/authors/2551368&quot; [10] &quot;/authors/125758&quot; [11] &quot;/authors/1819996&quot; [12] &quot;/authors/2353948&quot; [13] &quot;/authors/1819996&quot; [14] &quot;/authors/3664744&quot; [15] &quot;/authors/1819996&quot; [16] &quot;/authors/923348&quot; [17] &quot;/authors/153034&quot; [18] &quot;/authors/1819996&quot; [19] &quot;/authors/153034&quot; [20] &quot;/authors/4371126&quot; [21] &quot;/authors/923348&quot; [22] &quot;/authors/3601159&quot; [23] &quot;/authors/211970&quot; [24] &quot;/authors/4371126&quot; [25] &quot;/authors/2367076&quot; [26] &quot;/authors/108550&quot; [27] &quot;/authors/4888014&quot; [28] &quot;/authors/3093607&quot; [29] &quot;/authors/1753188&quot; [30] &quot;/authors/216926&quot; [31] &quot;/authors/4300578&quot; [32] &quot;/authors/1151836&quot; [33] &quot;/authors/407214&quot; [34] &quot;/authors/2353948&quot; [35] &quot;/authors/1188188&quot; [36] &quot;/authors/923348&quot; [37] &quot;/authors/4262993&quot; [38] &quot;/authors/185855&quot; [39] &quot;/authors/211970&quot; [40] &quot;/authors/1476905&quot; [41] &quot;/translations/by_author?author=sarahyyy&quot; [42] &quot;/authors/4712402&quot; [43] &quot;/authors/3043458&quot; [44] &quot;/authors/67708&quot; [45] &quot;/translations/by_author?author=vespertineflora&quot; [46] &quot;/authors/1541298&quot; [47] &quot;/authors/3664744&quot; [48] &quot;/authors/61509&quot; [49] &quot;/authors/907416&quot; [50] &quot;/authors/833307&quot; [51] &quot;/authors/3702102&quot; [52] &quot;/authors/90810&quot; Как видно, второй автор возникает, в случаях с переводом, так что можно их отфильтровать: tibble(authors, author_links) %&gt;% filter(!str_detect(author_links, &quot;translation&quot;)) %&gt;% bind_cols(pop_fan_fiction) -&gt; pop_fan_fiction glimpse(pop_fan_fiction) Rows: 50 Columns: 5 $ authors &lt;chr&gt; &quot;Канда Лотос&quot;, &quot;Канда Лотос&quot;, &quot;Канда Лотос&quot;, &quot;Канда Лото… $ author_links &lt;chr&gt; &quot;/authors/1819996&quot;, &quot;/authors/1819996&quot;, &quot;/authors/181999… $ name &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1… $ value &lt;chr&gt; &quot;Yellow&quot;, &quot;Сметана&quot;, &quot;Лисамайн&quot;, &quot;В Котисаари сегодня ос… $ link &lt;chr&gt; &quot;/readfic/10429398&quot;, &quot;/readfic/10357485&quot;, &quot;/readfic/1001… 4.3 Использование циклов Давайте попробуем скачать пэйринг. Наш старый способ посмотреть путь, не пройдет, туда попадает много мусора: source %&gt;% html_nodes(&quot;dl a&quot;) %&gt;% html_text() %&gt;% head() [1] &quot;Ориджиналы&quot; &quot;Амур/Ким&quot; &quot;2000-е годы&quot; &quot;Hurt/Comfort&quot; &quot;Буллинг&quot; [6] &quot;Взросление&quot; Во-первых, так как к одному фанфику есть много меток, нужно сохранить как-то группировку по фанфику. Для этого я запущу функцию map() из пакета purr, но если вам комфортнее использовать lapply(), то можно один заменить на другой. Ну и я понимаю, что не все могут быть в восторге от цикла в пайпе, конечно, это можно делать и по-другому. source %&gt;% html_nodes(&quot;article&quot;) %&gt;% map(function(x){ x %&gt;% html_nodes(&quot;dl a&quot;) %&gt;% html_text() }) -&gt; all_meta head(all_meta, n = 3) [[1]] [1] &quot;Ориджиналы&quot; &quot;Амур/Ким&quot; [3] &quot;2000-е годы&quot; &quot;Hurt/Comfort&quot; [5] &quot;Буллинг&quot; &quot;Взросление&quot; [7] &quot;Забота / Поддержка&quot; &quot;Мечты&quot; [9] &quot;Неловкость&quot; &quot;От друзей к возлюбленным&quot; [11] &quot;Первый поцелуй&quot; &quot;Первый раз&quot; [13] &quot;Переходный возраст&quot; &quot;Повседневность&quot; [15] &quot;Подростки&quot; &quot;Подростковая влюбленность&quot; [17] &quot;Преодоление комплексов&quot; &quot;Признания в любви&quot; [19] &quot;Прогулки&quot; &quot;Развитие отношений&quot; [21] &quot;Разговоры&quot; &quot;Романтика&quot; [23] &quot;Россия&quot; &quot;Сентиментальность&quot; [25] &quot;Сновидения&quot; &quot;Соблазнение / Ухаживания&quot; [27] &quot;Учебные заведения&quot; &quot;Флафф&quot; [29] &quot;Школьный роман&quot; [[2]] [1] &quot;Ориджиналы&quot; &quot;Чомор, Сметана, собаки, люди&quot; [3] &quot;Hurt/Comfort&quot; &quot;Возвращение&quot; [5] &quot;Выбор&quot; &quot;Вымышленные существа&quot; [7] &quot;Деревни&quot; &quot;Дикие животные&quot; [9] &quot;Домашние животные&quot; &quot;Древняя Русь&quot; [11] &quot;Дружба&quot; &quot;Духи природы&quot; [13] &quot;Жертвы обстоятельств&quot; &quot;Жестокое обращение с животными&quot; [15] &quot;Запахи&quot; &quot;Леса&quot; [17] &quot;Люди&quot; &quot;Магия&quot; [19] &quot;Моральные дилеммы&quot; &quot;Обретенные семьи&quot; [21] &quot;Охотники&quot; &quot;Побег из дома&quot; [23] &quot;Покровительство&quot; &quot;Покушение на жизнь&quot; [25] &quot;Приключения&quot; &quot;Принуждение&quot; [27] &quot;Разумные животные&quot; &quot;Самоопределение / Самопознание&quot; [29] &quot;Свобода&quot; &quot;Сказка&quot; [31] &quot;Смена сущности&quot; &quot;Тайна происхождения&quot; [33] &quot;Тайная сущность&quot; &quot;Фэнтези&quot; [35] &quot;Шейпшифтеры&quot; &quot;Элементы ангста&quot; [37] &quot;Элементы драмы&quot; &quot;Этническое фэнтези&quot; [[3]] [1] &quot;Ориджиналы&quot; &quot;Лис&quot; [3] &quot;Вымышленные существа&quot; &quot;Дарк&quot; [5] &quot;Духи природы&quot; &quot;Исповеди&quot; [7] &quot;Леса&quot; &quot;Магия&quot; [9] &quot;Мистика&quot; &quot;Мнимая проза&quot; [11] &quot;Немертвые&quot; &quot;Необратимые превращения&quot; [13] &quot;Нестандартная поэзия&quot; &quot;Нечеловеческие виды&quot; [15] &quot;Оборотни&quot; &quot;Повествование во втором лице&quot; [17] &quot;Погребение заживо&quot; &quot;Ритуалы&quot; [19] &quot;Стихи&quot; &quot;Тайная сущность&quot; [21] &quot;Тайны / Секреты&quot; &quot;Темное прошлое&quot; [23] &quot;Темное фэнтези&quot; &quot;Упоминания жестокости&quot; [25] &quot;Фэнтези&quot; &quot;Хэллоуин&quot; [27] &quot;Шейпшифтеры&quot; &quot;Элементы драмы&quot; [29] &quot;Элементы ужасов&quot; &quot;Этническое фэнтези&quot; Теперь мы получили то, что нужно, но он возвращает все метки. К сожалению создатели сайта не очень позаботились о том, чтобы упростить нам жизнь, поэтому мы воспользуемся трюком, которым мы пользовались раньше и скачаем еще и ссылки. source %&gt;% html_nodes(&quot;article&quot;) %&gt;% map(function(x){ x %&gt;% html_nodes(&quot;dl a&quot;) %&gt;% html_attr(&quot;href&quot;) }) -&gt; all_meta_links head(all_meta_links, n = 3) [[1]] [1] &quot;/fanfiction/no_fandom/originals&quot; [2] &quot;/pairings/%D0%90%D0%BC%D1%83%D1%80/%D0%9A%D0%B8%D0%BC&quot; [3] &quot;/tags/590&quot; [4] &quot;/tags/1682&quot; [5] &quot;/tags/436&quot; [6] &quot;/tags/909&quot; [7] &quot;/tags/1302&quot; [8] &quot;/tags/993&quot; [9] &quot;/tags/2459&quot; [10] &quot;/tags/344&quot; [11] &quot;/tags/2790&quot; [12] &quot;/tags/1292&quot; [13] &quot;/tags/1297&quot; [14] &quot;/tags/1677&quot; [15] &quot;/tags/218&quot; [16] &quot;/tags/581&quot; [17] &quot;/tags/588&quot; [18] &quot;/tags/1049&quot; [19] &quot;/tags/2462&quot; [20] &quot;/tags/1404&quot; [21] &quot;/tags/1401&quot; [22] &quot;/tags/1664&quot; [23] &quot;/tags/701&quot; [24] &quot;/tags/2567&quot; [25] &quot;/tags/490&quot; [26] &quot;/tags/616&quot; [27] &quot;/tags/1694&quot; [28] &quot;/tags/1667&quot; [29] &quot;/tags/2440&quot; [[2]] [1] &quot;/fanfiction/no_fandom/originals&quot; [2] &quot;/pairings/%D0%A7%D0%BE%D0%BC%D0%BE%D1%80,%20%D0%A1%D0%BC%D0%B5%D1%82%D0%B0%D0%BD%D0%B0,%20%D1%81%D0%BE%D0%B1%D0%B0%D0%BA%D0%B8,%20%D0%BB%D1%8E%D0%B4%D0%B8&quot; [3] &quot;/tags/1682&quot; [4] &quot;/tags/1522&quot; [5] &quot;/tags/2808&quot; [6] &quot;/tags/1685&quot; [7] &quot;/tags/364&quot; [8] &quot;/tags/622&quot; [9] &quot;/tags/517&quot; [10] &quot;/tags/466&quot; [11] &quot;/tags/1701&quot; [12] &quot;/tags/503&quot; [13] &quot;/tags/1475&quot; [14] &quot;/tags/722&quot; [15] &quot;/tags/1385&quot; [16] &quot;/tags/703&quot; [17] &quot;/tags/1538&quot; [18] &quot;/tags/1419&quot; [19] &quot;/tags/959&quot; [20] &quot;/tags/601&quot; [21] &quot;/tags/2036&quot; [22] &quot;/tags/2309&quot; [23] &quot;/tags/2223&quot; [24] &quot;/tags/1057&quot; [25] &quot;/tags/21&quot; [26] &quot;/tags/1323&quot; [27] &quot;/tags/895&quot; [28] &quot;/tags/1278&quot; [29] &quot;/tags/2166&quot; [30] &quot;/tags/288&quot; [31] &quot;/tags/1707&quot; [32] &quot;/tags/662&quot; [33] &quot;/tags/1512&quot; [34] &quot;/tags/1669&quot; [35] &quot;/tags/29&quot; [36] &quot;/tags/2696&quot; [37] &quot;/tags/2697&quot; [38] &quot;/tags/667&quot; [[3]] [1] &quot;/fanfiction/no_fandom/originals&quot; &quot;/pairings/%D0%9B%D0%B8%D1%81&quot; [3] &quot;/tags/1685&quot; &quot;/tags/1678&quot; [5] &quot;/tags/503&quot; &quot;/tags/1342&quot; [7] &quot;/tags/703&quot; &quot;/tags/1419&quot; [9] &quot;/tags/1671&quot; &quot;/tags/1098&quot; [11] &quot;/tags/495&quot; &quot;/tags/926&quot; [13] &quot;/tags/1704&quot; &quot;/tags/995&quot; [15] &quot;/tags/28&quot; &quot;/tags/166&quot; [17] &quot;/tags/1279&quot; &quot;/tags/749&quot; [19] &quot;/tags/1692&quot; &quot;/tags/1512&quot; [21] &quot;/tags/906&quot; &quot;/tags/2229&quot; [23] &quot;/tags/1963&quot; &quot;/tags/2447&quot; [25] &quot;/tags/1669&quot; &quot;/tags/205&quot; [27] &quot;/tags/29&quot; &quot;/tags/2697&quot; [29] &quot;/tags/2721&quot; &quot;/tags/667&quot; Теперь и all_meta, и all_meta_links — это список (объект типа list). В данном случае внутрюняя структуру списка не очень сложная, но она нам важна (ведь в одном фанфике может быть несколько пэйрингов). Так что сначала создадим вектор, в котором запишем, сколько элементов попалось в каждом из фанфиков. map_dbl(all_meta, length) [1] 29 38 30 44 12 28 8 7 12 14 33 18 31 15 27 11 11 44 12 5 12 10 9 8 12 [26] 3 17 10 10 13 12 8 22 25 17 14 11 8 10 12 9 14 7 27 8 17 6 7 19 15 Теперь мы можем создать вектор с повторяющимеся значениями и вставить его как индекс: tibble(meta = unlist(all_meta), links = unlist(all_meta_links), name = rep(pop_fan_fiction$value, map_dbl(all_meta, length))) Мы получили нужный датасет, теперь давайте отфильтруем и соединим: tibble(meta = unlist(all_meta), links = unlist(all_meta_links), value = rep(pop_fan_fiction$value, map_dbl(all_meta, length))) %&gt;% filter(str_detect(links, &quot;pairings&quot;)) %&gt;% select(-links) %&gt;% group_by(value) %&gt;% summarise(pairing = str_c(meta, collapse = &quot; | &quot;)) %&gt;% full_join(pop_fan_fiction) 4.4 Обкачивание нескольких страниц До сих пор мы обкачивали только одну страницу, но представим себе, что нам нужно обкачать много однотипных страниц. В нашем случае это могут быть разные разделы популярных фанфиков: В данном случае все эти ссылки уже есть на странице, так что мы можем их скачать: source %&gt;% html_nodes(&quot;a&quot;) %&gt;% html_attr(&quot;href&quot;) %&gt;% str_subset(&quot;popular/&quot;) -&gt; links_to_scrap Теперь давайте подоготовим функцию для обкачивания: my_scrap &lt;- function(x){ print(x) source &lt;- read_html(str_c(&quot;https://ficbook.net&quot;, x)) source %&gt;% html_nodes(&quot;h3 &gt; a&quot;) %&gt;% html_text() -&gt; titles source %&gt;% html_nodes(&quot;h3 &gt; a&quot;) %&gt;% html_attr(&quot;href&quot;) -&gt; links tibble(titles, links) } А теперь мы готовы соединить все вместе: result &lt;- map_dfr(links_to_scrap, my_scrap) [1] &quot;/popular/gen&quot; [1] &quot;/popular/het&quot; [1] &quot;/popular/slash&quot; [1] &quot;/popular/femslash&quot; [1] &quot;/popular/article&quot; [1] &quot;/popular/mixed&quot; [1] &quot;/popular/other&quot; result Часто генерация ссылок для скачивания достаточно проста, например, чтобы скачать все фанфики, посвященные “Очень старнным делам,” нужно будет обкачать 172 страницы, и, хотя на первой странице не указано ссылки, как появляется так много страниц становится понятно на второй странице: str_c(&quot;https://ficbook.net/fanfiction/movies_and_tv_series/ochenj_strannie_dela?p=&quot;, 1:172, &quot;.html&quot;) %&gt;% head() [1] &quot;https://ficbook.net/fanfiction/movies_and_tv_series/ochenj_strannie_dela?p=1.html&quot; [2] &quot;https://ficbook.net/fanfiction/movies_and_tv_series/ochenj_strannie_dela?p=2.html&quot; [3] &quot;https://ficbook.net/fanfiction/movies_and_tv_series/ochenj_strannie_dela?p=3.html&quot; [4] &quot;https://ficbook.net/fanfiction/movies_and_tv_series/ochenj_strannie_dela?p=4.html&quot; [5] &quot;https://ficbook.net/fanfiction/movies_and_tv_series/ochenj_strannie_dela?p=5.html&quot; [6] &quot;https://ficbook.net/fanfiction/movies_and_tv_series/ochenj_strannie_dela?p=6.html&quot; 4.4.1 Некоторые советы Некоторые ресурсы блокируют возможность скачивать из них данные. Обычно это делается на уровне сервера, который видит, что с какого-то IP приходит по 5 запросов в секунду и ограничивает доступ, на случай если вы начинаете DDoS атаку. Если сервер не отдает вам данные или отдает, но раз в какой-то временной промежуток, следует прописать в вашей программе ожидание (команда Sys.sleep()). Некоторые сайты, например, Википедия, специально архивирует данные, чтобы люди не пытались ее обкачать: вот страница, на которой это подробно описано. Обкачайте первые 10 страниц вашего фандома и сделайте следующую таблицу. "],["работа-с-текстами-gutenbergr-tidytext-stopwords-udpipe.html", "5 Работа с текстами: gutenbergr, tidytext, stopwords, udpipe 5.1 Загрузка текста в R 5.2 gutenbergr 5.3 tidytext и stopwords 5.4 Визуализация биграмм с igraph и ggraph 5.5 Пакет stopwords 5.6 Пакет udpipe 5.7 Задания", " 5 Работа с текстами: gutenbergr, tidytext, stopwords, udpipe Привет, дорогие пацаны и пацанессы! День второй, вы, предположительно, поразвлекались с регулярками, жизнь продолжается, давайте же анализировать тексты! В этом эпизоде сериала АйсДан мы выясним, как обычно выглядят текстовые данные (и откуда их, кстати, брать!), как мы хотим, чтобы текстовые данные выглядели, и как перевести одно в другое. Бонус: смешные графики! МЕСТО ДЛЯ ВИДЕО :)) В видео: 1) форматы текстовых данных (массив текста -&gt; term-document matrix) 2) Токены и токенизация 3) Стемминг и лемматизация Для начала давайте установим нужные библиотеки: 5.1 Загрузка текста в R В пакете readr, который входит в tidyverse, есть функция read_lines(). Такая же по сути функция есть в base R, она называется readLines(), но она работает гораздо медленнее, так что мы ей пользоваться не будем. read_lines() принимает на вход путь к файлу с текстом на вашем компьютере или ссылку на файл в Интернете. Например, у Гарика на гитхабе есть документ с текстом книги Теда Чана “История твоей жизни” (судя по Википедии, это научно-фантастическая повесть о лингвистке, изучающей язык пришельцев. Звучит прикольно). Давайте считаем этот файл. t &lt;- read_lines(&quot;https://raw.githubusercontent.com/agricolamz/2020_HSE_DPO/master/data/Chang.txt&quot;) head(t) [1] &quot;Тед Чан&quot; [2] &quot;История твоей жизни&quot; [3] &quot;Твой отец собирается задать мне вопрос. Это самый важный момент в нашей жизни, и я хочу&quot; [4] &quot;запомнить все до малейшей детали. Уже за полночь, но мы только что вернулись домой после&quot; [5] &quot;ужина в ресторане и веселого шоу и сразу выходим в патио полюбоваться полной луной. Хочу&quot; [6] &quot;танцевать! — объявляю я, и твой отец подтрунивает надо мной, но мы начинаем скользить в&quot; read_lines() создал вектор строк: class(t) [1] &quot;character&quot; В каждом элементе вектора у нас содержится одна строчка (в смысле, line) из книги. Чтобы превратить текст в единое целое, воспользуемся уже известной нам функцией str_c() из библиотеки stringr, и склеим, используя пробел как разделитель. t2 &lt;- stringr::str_c(t, collapse = &quot; &quot;) length(t2) [1] 1 str_length(t2) [1] 117398 При таком слиянии стоит проверить, не было ли в анализируемом тексте знаков переноса, иначе они сольются неправильно: str_c(c(&quot;... она запо-&quot;, &quot;лучила ...&quot;), collapse = &quot; &quot;) [1] &quot;... она запо- лучила ...&quot; 5.2 gutenbergr Библиотека gutenbergr это API для проекта Gutenberg - онлайн-библиотеки электронных книг, которую создал Майкл Харт, изобретатель, собственно, формата электронных книг. Там хранится куча документов, которые по каким-то причинам не защищены авторским правом, так что мы можем совершенно легально их скачивать и анализировать (ну, или читать). В этой библиотеке нас интересуют две вещи: объект gutenberg_metadata, в котором хранится информация о всех книгах, которые есть в библиотеке, и функция gutenberg_download(), которая позволяет их скачивать. Начнём с первого. str(gutenberg_metadata) tibble [51,997 × 8] (S3: tbl_df/tbl/data.frame) $ gutenberg_id : int [1:51997] 0 1 2 3 4 5 6 7 8 9 ... $ title : chr [1:51997] NA &quot;The Declaration of Independence of the United States of America&quot; &quot;The United States Bill of Rights\\r\\nThe Ten Original Amendments to the Constitution of the United States&quot; &quot;John F. Kennedy&#39;s Inaugural Address&quot; ... $ author : chr [1:51997] NA &quot;Jefferson, Thomas&quot; &quot;United States&quot; &quot;Kennedy, John F. (John Fitzgerald)&quot; ... $ gutenberg_author_id: int [1:51997] NA 1638 1 1666 3 1 4 NA 3 3 ... $ language : chr [1:51997] &quot;en&quot; &quot;en&quot; &quot;en&quot; &quot;en&quot; ... $ gutenberg_bookshelf: chr [1:51997] NA &quot;United States Law/American Revolutionary War/Politics&quot; &quot;American Revolutionary War/Politics/United States Law&quot; NA ... $ rights : chr [1:51997] &quot;Public domain in the USA.&quot; &quot;Public domain in the USA.&quot; &quot;Public domain in the USA.&quot; &quot;Public domain in the USA.&quot; ... $ has_text : logi [1:51997] TRUE TRUE TRUE TRUE TRUE TRUE ... - attr(*, &quot;date_updated&quot;)= Date[1:1], format: &quot;2016-05-05&quot; У каждого документа указан автор (если он есть) и название, author и title. Например, мы можем узнать, книг какого автора в библиотеке больше всего: gutenberg_metadata %&gt;% count(author, sort = TRUE) Сколько произведений Джейн Остин (не перепутайте с другими Остин) есть в датасете? gutenberg_metadata %&gt;% filter(author == &quot;Austen, Jane&quot;) %&gt;% distinct(gutenberg_id, title) Ещё у каждой книги есть свой уникальный ID, который хранится в колонке gutenberg_id. По этому ID книгу можно скачать, используя функцию gutenberg_download(). Давайте скачаем “Эмму”: emma &lt;- gutenberg_download(158, mirror = &quot;http://mirrors.xmission.com/gutenberg/&quot;) emma Можно скачивать сразу несколько книг. Давайте добавим еще “Леди Сьюзен”: books &lt;- gutenberg_download(c(158, 946), meta_fields = &quot;title&quot;, mirror = &quot;http://mirrors.xmission.com/gutenberg/&quot;) books books %&gt;% count(title) Сколько уникальных заголовков из базы данных содержит “Sherlock Holmes?” 5.3 tidytext и stopwords Сейчас наши книги хранятся в тиббле, в котором есть три колонки: class(books) [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; colnames(books) [1] &quot;gutenberg_id&quot; &quot;text&quot; &quot;title&quot; Причём для каждой из книг у нас куча строк: books %&gt;% count(title) Это потому что одна строка в тиббле это одна строка книги. Мы можем снова воспользоваться функцией str_c() и слить весь текст в одну гигантскую строку, но вместо этого мы токенизируем наши тексты, используя в качестве токенов (=смысловых единиц) слова. Если вы посмотрели видео в начале, то уже знаете, что такое токенизация, а если не посмотрели, то идите и посмотрите :) Для токенизации мы будем использовать функцию unnest_tokens() из библиотеки tidytext (про эту библиотеку есть книга, которую можно прочитать здесь). В аргумент output функции unnest_tokens() подается вектор с именем будущей переменной, а аргумент input принимает имя переменной, в которой в нашем тиббле хранится текст. По умолчанию unnest_tokens() делит текст на слова, хотя есть и другие опции, которые можно указать в аргументе token. Но пока давайте поисследуем слова. library(tidytext) books %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) Теперь можно посчитать самые частотные слова в обоих произведениях: books %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) %&gt;% count(title, word, sort = TRUE) Ну… Это было ожидаемо. Нужно убрать стоп-слова. Английские стоп-слова встроены в пакет tidytext (переменная stop_words): books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% anti_join(stop_words) Постройте следующий график, на котором представлены самые частотные 20 слов каждого из произведений. Как видно, на графике всё не упорядочено, давайте начнем с такого примера: books %&gt;% unnest_tokens(word, text) %&gt;% count(word, sort = TRUE) %&gt;% slice(1:20) %&gt;% ggplot(aes(n, word))+ geom_col() Если мы работаем с одним фасетом, то все проблемы может решить функция fct_reorder(), которая упорядочивает на основании некоторой переменной: books %&gt;% unnest_tokens(word, text) %&gt;% count(word, sort = TRUE) %&gt;% slice(1:20) %&gt;% mutate(word = fct_reorder(word, n)) %&gt;% ggplot(aes(n, word))+ geom_col() Однако, если мы применим это к нашим данным, то получится неупорядочено, потому что fct_reorder()упорядочивает, не учитывая, где какой текст: books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% group_by(title) %&gt;% slice(1:20) %&gt;% ungroup() %&gt;% mutate(word = fct_reorder(word, n)) %&gt;% ggplot(aes(n, word))+ geom_col()+ facet_wrap(~title, scales = &quot;free&quot;) В пакете tidytext есть функция reorder_within(), которая позволяет упорядочить нужным образом: books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% group_by(title) %&gt;% slice(1:20) %&gt;% ungroup() %&gt;% mutate(word = reorder_within(x = word, by = n, within = title)) %&gt;% ggplot(aes(n, word))+ geom_col()+ facet_wrap(~title, scales = &quot;free&quot;) Чтобы избавиться от дополнительной подписи, нужно использовать scale_y_reordered() или scale_x_reordered(): books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% group_by(title) %&gt;% slice(1:20) %&gt;% ungroup() %&gt;% mutate(word = reorder_within(x = word, by = n, within = title)) %&gt;% ggplot(aes(n, word))+ geom_col()+ facet_wrap(~title, scales = &quot;free&quot;)+ scale_y_reordered() Ещё один способ графически представить самые частотные слова это сделать облако слов. Есть библиотека wordclouds с функцией wordcloud. Давайте построим облако слов для романа Lady Susan. Для раскрашивания слов в разные цвета я использую палитру из великой библиотеки wesanderson с цветами разных фильмов, собственно, Уэса Андерсона. pal &lt;- wes_palette(&quot;Royal2&quot;) books %&gt;% filter(title == &#39;Lady Susan&#39;) %&gt;% unnest_tokens(input = &#39;text&#39;, output = &#39;word&#39;) %&gt;% count(title, word, sort = TRUE) %&gt;% anti_join(stop_words) %&gt;% with(wordcloud(word, n, random.order = FALSE, max.words = 50, colors=pal)) wordcloud, к сожалению, не совместим с ggplot2 без которого, например, гораздо сложнее сделать фасетизацию и не задолбаться. Зато есть библиотека ggwordcloud, в которой есть geom_text_wordcloud. Воспользуемся же им! Предварительное предупреждение: если слов в облако надо вместить много, то `ggwordcloud указывает для редко встречающихся очень маленький размер шрифта. ggplot от этого волнуется и выдаёт ворнинги, по одному на каждое слово. Это я к чему: график в чанке снизу выдаёт миллион ворнингов. В этом мануале они спрятаны, а когда столкнётесь с ними при выполнении заданий, можете их игнорировать. И, конечно, совершенно не обязательно включать слова, которые встречаются всего пару раз в очень длинном тексте. books %&gt;% unnest_tokens(input = &#39;text&#39;, output = &#39;word&#39;) %&gt;% count(title, word, sort = TRUE) %&gt;% anti_join(stop_words) %&gt;% filter(n &gt; 20) %&gt;% ggplot(aes(label = word, size = n, color = n)) + geom_text_wordcloud(rm_outside = TRUE) + facet_wrap(~title, scale = &#39;free&#39;) + scale_size_area(max_size = 10) Поиск самых частотных слов — не единственная задача, которую можно решать при работе с текстом. Иногда имеет смысл узнать распределение слов в произведении. Давайте посмотрим как распределены в романе “Эмма” фамилии главных героев: books %&gt;% filter(title == &quot;Emma&quot;) %&gt;% unnest_tokens(word, text) %&gt;% mutate(narrative_time = 1:n()) %&gt;% filter(str_detect(word, &quot;knightley$|woodhouse$|churchill$|fairfax$&quot;)) %&gt;% ggplot()+ geom_vline(aes(xintercept = narrative_time))+ facet_wrap(~word, ncol = 1) Функция unnest_tokens() позволяет работать не только со словами, но и, напрмиер, с n-граммами, то есть сочетаниями из n слов. Важно понимать, что n-граммы образуются “внахлёст”: txt &lt;- tibble(text = &quot;I&#39;m a Barbie girl in a Barbie world&quot;) txt %&gt;% unnest_tokens(bigram, text, token = &quot;ngrams&quot;, n = 2) Чтобы преобразовать текст в биграммы, надо уточнить, что token = \"ngrams\", а n=2. books %&gt;% unnest_tokens(bigram, text, token = &quot;ngrams&quot;, n = 2) Если мы посмотрим на самые частотные биграммы, то увидим кучу несодержательных вещей. books %&gt;% unnest_tokens(bigram, text, token = &quot;ngrams&quot;, n = 2) %&gt;% count(bigram, sort = TRUE) Почему? Снова стоп-слова-злодеи! Чтобы их убрать, надо разделить биграммы, отфильтровать так, чтобы остались только биграммы без стоп-слов, и снова склеить. Для этого мы воспользуемся функциями separate и unite, вот так (и заодно избавимся от NA’ев): books %&gt;% unnest_tokens(bigram, text, token = &quot;ngrams&quot;, n = 2) %&gt;% drop_na()%&gt;% separate(bigram, c(&#39;word1&#39;, &#39;word2&#39;), sep = &#39; &#39;) %&gt;% filter(!(word1 %in% stop_words$word) &amp; !(word2 %in% stop_words$word)) %&gt;% count(word1, word2, sort = TRUE) %&gt;% unite(bigram, word1, word2, sep = &quot; &quot;) 5.4 Визуализация биграмм с igraph и ggraph Биграммы можно представить теми же способами, что и слова, а можно визуализировать сеть связей между словами в таком как бы графе. Для этого мы будем пользоваться двумя библиотеками: igraph и ggraph. Из igraph нам понадобится функция graph_from_data_frame(), которой мы скормим тиббл с данными о частотности биграмм, а ggraph будем использовать, чтобы построить график. Для графика нам нужно три переменных: - from, от какого “узла” (слова) начинается связь - to, в какой узел (слово) связь идёт - weight, вес этой связи. В нашем случае - насколько часто эта связь (то есть, конкретная биграмма) встречается в тексте. graph_from_data_frame() берёт тиббл (или любой дата фрейм) с этой информацией и преобразует его в объект, из которого можно делать граф. Давайте совершим все эти преобразования и заодно оставим только биграммы, которых больше 20: bigrams_graph &lt;- books %&gt;% unnest_tokens(bigram, text, token = &quot;ngrams&quot;, n = 2) %&gt;% drop_na() %&gt;% separate(bigram, c(&quot;word1&quot;, &quot;word2&quot;), sep = &quot; &quot;) %&gt;% filter(!(word1 %in% stop_words$word) &amp; !(word2 %in% stop_words$word)) %&gt;% count(word1, word2, sort = TRUE) %&gt;% filter(n &gt; 20) %&gt;% graph_from_data_frame() bigrams_graph IGRAPH fe287f5 DN-- 25 17 -- + attr: name (v/c), n (e/n) + edges from fe287f5 (vertex names): [1] miss -&gt;woodhouse frank -&gt;churchill miss -&gt;fairfax miss -&gt;bates [5] jane -&gt;fairfax lady -&gt;susan de -&gt;courcy miss -&gt;smith [9] sir -&gt;james john -&gt;knightley miss -&gt;taylor dear -&gt;emma [13] maple -&gt;grove cried -&gt;emma dear -&gt;miss harriet-&gt;smith [17] robert -&gt;martin А теперь можно и график делать: ggraph(bigrams_graph, layout = &quot;fr&quot;) + geom_edge_link() + geom_node_point() + geom_node_text(aes(label = name), vjust = 1, hjust = 1) 5.5 Пакет stopwords Выше мы упомянули, что в пакет tidytext встроен список английских стоп-слов. Стоп-слова для других язков можно раздобыть, используя пакет stopwords. Вместо имени языка, функция принимает ISO-код языка: library(stopwords) stopwords(&quot;ru&quot;) [1] &quot;и&quot; &quot;в&quot; &quot;во&quot; &quot;не&quot; &quot;что&quot; &quot;он&quot; &quot;на&quot; [8] &quot;я&quot; &quot;с&quot; &quot;со&quot; &quot;как&quot; &quot;а&quot; &quot;то&quot; &quot;все&quot; [15] &quot;она&quot; &quot;так&quot; &quot;его&quot; &quot;но&quot; &quot;да&quot; &quot;ты&quot; &quot;к&quot; [22] &quot;у&quot; &quot;же&quot; &quot;вы&quot; &quot;за&quot; &quot;бы&quot; &quot;по&quot; &quot;только&quot; [29] &quot;ее&quot; &quot;мне&quot; &quot;было&quot; &quot;вот&quot; &quot;от&quot; &quot;меня&quot; &quot;еще&quot; [36] &quot;нет&quot; &quot;о&quot; &quot;из&quot; &quot;ему&quot; &quot;теперь&quot; &quot;когда&quot; &quot;даже&quot; [43] &quot;ну&quot; &quot;вдруг&quot; &quot;ли&quot; &quot;если&quot; &quot;уже&quot; &quot;или&quot; &quot;ни&quot; [50] &quot;быть&quot; &quot;был&quot; &quot;него&quot; &quot;до&quot; &quot;вас&quot; &quot;нибудь&quot; &quot;опять&quot; [57] &quot;уж&quot; &quot;вам&quot; &quot;сказал&quot; &quot;ведь&quot; &quot;там&quot; &quot;потом&quot; &quot;себя&quot; [64] &quot;ничего&quot; &quot;ей&quot; &quot;может&quot; &quot;они&quot; &quot;тут&quot; &quot;где&quot; &quot;есть&quot; [71] &quot;надо&quot; &quot;ней&quot; &quot;для&quot; &quot;мы&quot; &quot;тебя&quot; &quot;их&quot; &quot;чем&quot; [78] &quot;была&quot; &quot;сам&quot; &quot;чтоб&quot; &quot;без&quot; &quot;будто&quot; &quot;человек&quot; &quot;чего&quot; [85] &quot;раз&quot; &quot;тоже&quot; &quot;себе&quot; &quot;под&quot; &quot;жизнь&quot; &quot;будет&quot; &quot;ж&quot; [92] &quot;тогда&quot; &quot;кто&quot; &quot;этот&quot; &quot;говорил&quot; &quot;того&quot; &quot;потому&quot; &quot;этого&quot; [99] &quot;какой&quot; &quot;совсем&quot; &quot;ним&quot; &quot;здесь&quot; &quot;этом&quot; &quot;один&quot; &quot;почти&quot; [106] &quot;мой&quot; &quot;тем&quot; &quot;чтобы&quot; &quot;нее&quot; &quot;кажется&quot; &quot;сейчас&quot; &quot;были&quot; [113] &quot;куда&quot; &quot;зачем&quot; &quot;сказать&quot; &quot;всех&quot; &quot;никогда&quot; &quot;сегодня&quot; &quot;можно&quot; [120] &quot;при&quot; &quot;наконец&quot; &quot;два&quot; &quot;об&quot; &quot;другой&quot; &quot;хоть&quot; &quot;после&quot; [127] &quot;над&quot; &quot;больше&quot; &quot;тот&quot; &quot;через&quot; &quot;эти&quot; &quot;нас&quot; &quot;про&quot; [134] &quot;всего&quot; &quot;них&quot; &quot;какая&quot; &quot;много&quot; &quot;разве&quot; &quot;сказала&quot; &quot;три&quot; [141] &quot;эту&quot; &quot;моя&quot; &quot;впрочем&quot; &quot;хорошо&quot; &quot;свою&quot; &quot;этой&quot; &quot;перед&quot; [148] &quot;иногда&quot; &quot;лучше&quot; &quot;чуть&quot; &quot;том&quot; &quot;нельзя&quot; &quot;такой&quot; &quot;им&quot; [155] &quot;более&quot; &quot;всегда&quot; &quot;конечно&quot; &quot;всю&quot; &quot;между&quot; Пакет предоставляет несколько источников списков: stopwords_getsources() [1] &quot;snowball&quot; &quot;stopwords-iso&quot; &quot;misc&quot; &quot;smart&quot; [5] &quot;marimo&quot; &quot;ancient&quot; &quot;nltk&quot; Давайте посмотрим, какие языки сейчас доступны: map(stopwords_getsources(), stopwords_getlanguages) [[1]] [1] &quot;da&quot; &quot;de&quot; &quot;en&quot; &quot;es&quot; &quot;fi&quot; &quot;fr&quot; &quot;hu&quot; &quot;ir&quot; &quot;it&quot; &quot;nl&quot; &quot;no&quot; &quot;pt&quot; &quot;ro&quot; &quot;ru&quot; &quot;sv&quot; [[2]] [1] &quot;af&quot; &quot;ar&quot; &quot;hy&quot; &quot;eu&quot; &quot;bn&quot; &quot;br&quot; &quot;bg&quot; &quot;ca&quot; &quot;zh&quot; &quot;hr&quot; &quot;cs&quot; &quot;da&quot; &quot;nl&quot; &quot;en&quot; &quot;eo&quot; [16] &quot;et&quot; &quot;fi&quot; &quot;fr&quot; &quot;gl&quot; &quot;de&quot; &quot;el&quot; &quot;ha&quot; &quot;he&quot; &quot;hi&quot; &quot;hu&quot; &quot;id&quot; &quot;ga&quot; &quot;it&quot; &quot;ja&quot; &quot;ko&quot; [31] &quot;ku&quot; &quot;la&quot; &quot;lt&quot; &quot;lv&quot; &quot;ms&quot; &quot;mr&quot; &quot;no&quot; &quot;fa&quot; &quot;pl&quot; &quot;pt&quot; &quot;ro&quot; &quot;ru&quot; &quot;sk&quot; &quot;sl&quot; &quot;so&quot; [46] &quot;st&quot; &quot;es&quot; &quot;sw&quot; &quot;sv&quot; &quot;th&quot; &quot;tl&quot; &quot;tr&quot; &quot;uk&quot; &quot;ur&quot; &quot;vi&quot; &quot;yo&quot; &quot;zu&quot; [[3]] [1] &quot;ar&quot; &quot;ca&quot; &quot;el&quot; &quot;gu&quot; &quot;zh&quot; [[4]] [1] &quot;en&quot; [[5]] [1] &quot;en&quot; &quot;ja&quot; &quot;ar&quot; &quot;he&quot; &quot;zh_tw&quot; &quot;zh_cn&quot; [[6]] [1] &quot;grc&quot; &quot;la&quot; [[7]] [1] &quot;ar&quot; &quot;az&quot; &quot;da&quot; &quot;nl&quot; &quot;en&quot; &quot;fi&quot; &quot;fr&quot; &quot;de&quot; &quot;el&quot; &quot;hu&quot; &quot;id&quot; &quot;it&quot; &quot;kk&quot; &quot;ne&quot; &quot;no&quot; [16] &quot;pt&quot; &quot;ro&quot; &quot;ru&quot; &quot;sl&quot; &quot;es&quot; &quot;sv&quot; &quot;tg&quot; &quot;tr&quot; Мы видим, что есть несколько источников для русского языка: length(stopwords(&quot;ru&quot;, source = &quot;snowball&quot;)) [1] 159 length(stopwords(&quot;ru&quot;, source = &quot;stopwords-iso&quot;)) [1] 559 В зависимости от того, насколько консервативными вы хотите быть в плане стоп-слов (например, “сказал” это стоп-слово или нет?), можете выбирать тот или другой список. Ну и всегда можно попробовать оба и выбрать тот, который даёт более осмысленный результат. 5.6 Пакет udpipe Пакет udpipe представляет лемматизацию, морфологический и синтаксический анализ разных языков. Туториал можно найти здесь, там же есть список доступных языков. library(udpipe) Модели качаются очень долго. enmodel &lt;- udpipe_download_model(language = &quot;english&quot;) Теперь можно распарсить какое-нибудь предложение: udpipe(&quot;The want of Miss Taylor would be felt every hour of every day.&quot;, object = enmodel) Скачаем русскую модель: rumodel &lt;- udpipe_download_model(language = &quot;russian-syntagrus&quot;) udpipe(&quot;Жила-была на свете крыса в морском порту Вальпараисо, на складе мяса и маиса, какао и вина.&quot;, object = rumodel) После того, как модель скачана, можно уже к ней обращаться просто по имени файла: udpipe(&quot;Жила-была на свете крыса в морском порту Вальпараисо, на складе мяса и маиса, какао и вина.&quot;, object = rumodel) udpipe лемматизирует наш текст (то есть, теперь “мясо” и “мяса” распрознаются как одно и то же слово), а также помечает, к какой части речи это слово относится, по универсальной классификации. С таким текстом, например, можно посмотреть на то, как часто встречаются только определённые части речи. И последний комментарий про udpipe: лемматизациz дело не быстрое, поэтому, скорее всего, лемматизировать все фанфики скопом у вас не получится. Вместо этого предлагается сделать сэмпл (то есть, рандомно выбрать, например, 300 фанфиков) и работать с ними. Если 300 вашему компьютеру тяжело - можно меньше. Соответственно, в заданиях, где нужна лемматизация, сэмплируйте датасет и работайте с сэмплом. А теперь - собственно, задания! 5.7 Задания Найдите три самыx популярных (по количеству лайков) фанфика и постройте барплоты для самых часто встречающихся слов в этих фанфиках. Найдите самый длинный фанфик (не забывайте, что в нашем датасете одна строка это одна глава, а глав бывает несколько) и постройте для него граф биграмм (не всех, конечно, а тех, что встречаются чаще скольки-то раз). Для того же самого длинного фанфика по самым частотным словам поймите, какие в нём есть персонажи и как их зовут. Постройте график, который показывает, как частота появления разных персонажей меняется на протяжении фанфика. Какие прилагательные чаще всего используются в вашем фандоме со словом “глаз” (в любой форме)? Проиллюстрируйте облаком слов. Именно здесь вам понадобится лемматизация, так что используйте сэмпл. Найдите самого плодовитого автора в вашем фандоме (то есть, такого, который написал больше всего фанфиков). Попробуйте найти клише, которые встречаются в его или её текстах. Тут можно посмотреть на биграммы, триграммы или и то, и другое - посмотрите, что интереснее, и покажите на графике (можно барплот, можно сделать облако слов, можете придумать свой вариант). Если у вас появятся вопросы - смело задавайте их в канале #text-preprocessing-questions, а все странные и нелепые графики присылайте в #accidental-art. Удачи! "],["анализ-текста.html", "6 Анализ текста 6.1 Данные 6.2 tf-idf 6.3 Предиктивный ввод текста 6.4 Анализ тональности 6.5 Тематическое моделирование", " 6 Анализ текста 6.1 Данные Для работы мы воспользуемся двумя датасетами: Фэндом Мерлин me &lt;- read_csv(&quot;data_ficbook_merlin.csv&quot;) me Фэндом 30 seconds to mars mars30 &lt;- read_csv(&quot;data_ficbook_30_seconds_to_mars.csv&quot;) mars30 Возьмем выборку в 50 фанфиков (на моем компьютере это обрабатовалось минуты 4), соединим, лемматизируем и уберем стопслова. library(stopwords) library(udpipe) rus &lt;- udpipe_load_model(&quot;russian-syntagrus-ud-2.4-190531.udpipe&quot;) set.seed(42) me %&gt;% sample_n(50) %&gt;% rename(doc_id = subtitle) %&gt;% udpipe(object = rus, parallel.cores = 7) %&gt;% mutate(fandom = &quot;merlin&quot;) -&gt; me_sample set.seed(42) mars30 %&gt;% sample_n(50) %&gt;% rename(doc_id = subtitle) %&gt;% udpipe(object = rus, parallel.cores = 7) %&gt;% mutate(fandom = &quot;mars30&quot;) -&gt; mars30_sample me_sample %&gt;% bind_rows(mars30_sample) %&gt;% filter(!str_detect(lemma, &quot;\\\\W|\\\\d&quot;)) %&gt;% anti_join(tibble(lemma = stopwords(language = &quot;ru&quot;))) %&gt;% select(doc_id, sentence_id, lemma, fandom) -&gt; all_texts all_texts Повторите эти действия с сэмплами из других фандомов. Лучше использовать высокорейтинговые фанфики. 6.2 tf-idf tf-idf — важная мера, которая позволяет выделять важные для текста слова. \\[tf = \\frac{количество\\ употреблений\\ единицы\\ в\\ тексте}{количество\\ единиц\\ в тексте}\\] \\[idf = log\\left(\\frac{количество\\ документов\\ в\\ корпусе}{количество\\ документов\\ с\\ исследуемой\\ единицей}\\right)\\] \\[TfIdf = tf \\times idf\\] Для начала нарисуем топ 10 слов в обоих фандомах: library(tidytext) all_texts %&gt;% count(lemma, fandom) %&gt;% mutate(lemma = reorder_within(lemma, n, fandom)) %&gt;% group_by(fandom) %&gt;% top_n(10) %&gt;% ggplot(aes(n, lemma))+ geom_col()+ facet_wrap(~fandom, scales = &quot;free&quot;)+ scale_y_reordered() А теперь сравним получившееся с мерой tf-idf: library(tidytext) all_texts %&gt;% count(lemma, fandom) %&gt;% bind_tf_idf(lemma, fandom, n) %&gt;% group_by(fandom) %&gt;% top_n(10) %&gt;% mutate(lemma = reorder_within(lemma, tf_idf, fandom)) %&gt;% ggplot(aes(tf_idf, lemma))+ geom_col()+ facet_wrap(~fandom, scales = &quot;free&quot;)+ scale_y_reordered() Повторите со своей выборкой фанфиков. Лучше использовать высокорейтинговые. 6.3 Предиктивный ввод текста На прошлых занятиях мы разобрались, что пакет tidytext позволяет делить не только на отдльные слова, но и смотреть на биграммы. Частотность биграмм можно использовать в подсказке слова, которую мы видим в наших телефонах: set.seed(42) me %&gt;% sample_n(50) %&gt;% unnest_tokens(&quot;bigram&quot;, text, token = &quot;ngrams&quot;, n = 2) %&gt;% separate(bigram, into = c(&quot;word_1&quot;, &quot;word_2&quot;), &quot; &quot;) %&gt;% count(word_1, word_2, sort = TRUE) -&gt; bigrams Теперь у нас есть биграмы: bigrams %&gt;% filter(word_1 == &quot;однажды&quot;) bigrams %&gt;% filter(word_1 == &quot;мерлин&quot;) bigrams %&gt;% filter(word_1 == &quot;не&quot;) bigrams %&gt;% filter(word_1 == &quot;мог&quot;) bigrams %&gt;% filter(word_1 == &quot;понять&quot;) %&gt;% head() bigrams %&gt;% filter(word_1 == &quot;что&quot;) %&gt;% head() bigrams %&gt;% filter(word_1 == &quot;он&quot;) %&gt;% head() bigrams %&gt;% filter(word_1 == &quot;снова&quot;) %&gt;% head() bigrams %&gt;% filter(word_1 == &quot;попытался&quot;) %&gt;% head() bigrams %&gt;% filter(word_1 == &quot;встать&quot;) %&gt;% head() Вот мы и получили предложение “Однажды Мерлин не мог понять, что он снова пытался встать.” На большом корпусе результаты будут лучше, но легко предсатвить, как сделать из этого рабочую функцию. Можно переиначить задачу и работать с символами, тогда это будет ближе к T9 на современных телефонах. Попробуйте получить осмысленное предложение на основе своих фанфиков. Лучше использовать высокорейтинговые. 6.4 Анализ тональности Linis Crowd лемма значение среднеквадратичное отклонение РуСентиЛекс: слово или словосочетание, часть речи или синтаксический тип группы, слово или словосочетание в лемматизированной форме, тональность: позитивная (positive), негативная(negative), нейтральная (neutral) или неопределеная оценка, зависит от контекста (positive/negative), источник: оценка (opinion), чувство (feeling), факт (fact), если тональность отличается для разных значений многозначного слова, то перечисляются все значения слова по тезаурусу РуТез и дается отсылка на сооветствующее понятие - имя понятия в кавычках. Мы будем использовать датасет, составленный на базе Linis Crowd ru_sentiments &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020_HSE_DPO/master/data/ru_sentiment_linis-crowd.csv&quot;) set.seed(42) all_texts %&gt;% filter(doc_id %in% sample(unique(all_texts$doc_id), 6)) %&gt;% group_by(doc_id) %&gt;% left_join(ru_sentiments, by = c(&quot;lemma&quot; = &quot;words&quot;)) %&gt;% mutate(value = ifelse(is.na(value), 0, value)) %&gt;% group_by(doc_id, sentence_id) %&gt;% summarise(value = sum(value)) %&gt;% mutate(color = ifelse(value &gt;= 0, &quot;positive&quot;, &quot;negative&quot;)) %&gt;% ggplot(aes(sentence_id, value, fill = color))+ geom_col()+ facet_wrap(~doc_id, scales = &quot;free&quot;) Попробуйте получить осмысленное предложение на основе своих фанфиков. Лучше использовать высокорейтинговые. 6.5 Тематическое моделирование LDA (Latent Dirichlet allocation) — один из базовых способов, используемый в тематическом моделировании. Основное идея алгаритма, заключается в том, что каждый текст может являтся смесью тем, а каждая тема имеет вероятность более высокую вероятность генерировать некоторые слова, и более низкую вероятность генерировать слова общие для всех тем. На вход подается посчитанный список слов для каждого текста. library(topicmodels) all_texts %&gt;% count(doc_id, lemma) %&gt;% cast_dtm(doc_id, lemma, n) %&gt;% # особая функция LDA(k = 2, # количество тем control = list(seed = 42) # повзоляет воспроизвести один и тот же анализ, можно убрать ) -&gt; lda Посмотрим, какие слова характерны для какой темы (т. е. самые частотные в теме): lda %&gt;% tidy(matrix = &quot;beta&quot;) %&gt;% # приводим модель в tidy формат group_by(topic) %&gt;% top_n(15, beta) %&gt;% ungroup() %&gt;% mutate(term = reorder_within(term, beta, topic)) %&gt;% ggplot(aes(term, beta, fill = factor(topic))) + geom_col(show.legend = FALSE) + facet_wrap(~topic, scales = &quot;free&quot;) + coord_flip() + scale_x_reordered() Посмотрим, какие слова специфичны для каждой из тем (т. е. частота значительно больше в одной теме, чем в другой): lda %&gt;% tidy(matrix = &quot;beta&quot;) %&gt;% mutate(topic = paste0(&quot;topic&quot;, topic)) %&gt;% spread(topic, beta) %&gt;% filter(topic1 &gt; .006 | topic2 &gt; .002) %&gt;% # эти значения нужно вручную подбирать mutate(log_ratio = log2(topic2 / topic1), term = fct_reorder(term, log_ratio)) %&gt;% ggplot(aes(log_ratio, term))+ geom_col() Посмотрим на распределение текстов по темам: lda %&gt;% tidy(matrix = &quot;gamma&quot;) "],["еще-разные-задачи-и-пакеты-для-этого-бонус.html", "7 Еще разные задачи и пакеты для этого (бонус)", " 7 Еще разные задачи и пакеты для этого (бонус) By Юля Мартысенко "]]
