[["index.html", "Зимняя школа АйсДан 2021: скрейпинг и анализ текстовых данных 1 О курсе", " Зимняя школа АйсДан 2021: скрейпинг и анализ текстовых данных М. Серветник, А. Котликова, Ю. Мартысенко, Г. Мороз, Ф. Управителев 1 О курсе Материалы для курса зимней школы Анализа данных: скрейпинг и анализ текстовых данных. "],["работа-со-строками.html", "2 Работа со строками 2.1 Запись строк 2.2 Количество символов 2.3 Сортировка 2.4 Конкатенация 2.5 Работа с подстрокой 2.6 Изменение строки 2.7 Пакеты для работы с текстовыми данными 2.8 Задания 2.9 Sources", " 2 Работа со строками Видео-приветствие “Всем привет! Меня зовут Юля. Я напомню вам о работе со строками в R. Мы посмотрим, как выглядят строки в R, как их можно соединять-разделять, какие функции есть для работы с ними (например,сортировка, поиск и замена подстроки, изменение регистра, транслитеряция и пр). Также мы потрогаем несколько удобных библиотек для работы со строковыми данными. Поехали!” Работать со строками можно с помощью base R, но чаще всего удобнее пользоваться специальными пакетами: * stringr, который входит в tidyverse (‘str_’) * stringi (‘stri_’) library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.3 ✓ purrr 0.3.4 ## ✓ tibble 3.0.6 ✓ dplyr 1.0.4 ## ✓ tidyr 1.1.2 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(stringi) 2.1 Запись строк Для начала посмотрим, как можно получить строку. Присвоение Надо вот так: string1 &lt;- &quot;Я строка&quot; string2 &lt;- &#39;И я строка&#39; string1 ## [1] &quot;Я строка&quot; string2 ## [1] &quot;И я строка&quot; Вот так вот не надо: string3 &lt;- &quot;Я тоже своего рода &quot;строка&quot; string3 ## Error: &lt;text&gt;:1:33: unexpected symbol ## 1: string3 &lt;- &quot;Я тоже своего рода &quot;строка ## ^ NB! Следите за кавычками string4 &lt;- &quot;Ну вот &#39;так&#39; вроде норм&quot; string5 &lt;- &#39;И &quot;так&quot; тоже&#39; string4 ## [1] &quot;Ну вот &#39;так&#39; вроде норм&quot; string5 ## [1] &quot;И \\&quot;так\\&quot; тоже&quot; Экранирование: string6 &lt;- &quot;Экранирование \\&quot;лишних\\&quot; кавычек&quot; string6 ## [1] &quot;Экранирование \\&quot;лишних\\&quot; кавычек&quot; Печать строки Функции для печати строк вам, скорее всего, известны: print, paste, paste0, cat, noquote, format format(13.495902982, digits=5) ## [1] &quot;13.496&quot; Преобразование typeof(4:7) ## [1] &quot;integer&quot; as.character(4:7) ## [1] &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; string7 &lt;- (1:9) ^ 2 toString (string7) ## [1] &quot;1, 4, 9, 16, 25, 36, 49, 64, 81&quot; Преобразование таблиц в строки NB! Функции data.frame(), read.csv(), read.csv2(), read.table() из base R по-умолчанию превращают строки в факторы. Чтобы этого избежать, необходимо указать аргумент stringsAsFactors = FALSE. str(data.frame(letters[1:5], LETTERS[1:5])) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ letters.1.5.: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ LETTERS.1.5.: chr &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... str(data.frame(letters[1:5], LETTERS[1:5], stringsAsFactors = FALSE)) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ letters.1.5.: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ LETTERS.1.5.: chr &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... Генерация Генерация пустых строк character(3) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; Генерация рандомных строк set.seed(42) stri_rand_strings(n = 10, length = 5:14) ## [1] &quot;uwHpd&quot; &quot;Wj8ehS&quot; &quot;ivFSwy7&quot; &quot;TYu8zw5V&quot; ## [5] &quot;OuRpjoOg0&quot; &quot;p0CubNR2yQ&quot; &quot;xtdycKLOm2k&quot; &quot;fAGVfylZqBGp&quot; ## [9] &quot;gE28DTCi0NV0a&quot; &quot;9MemYE55If0Cvv&quot; Генерация псевдорандомных строк (классический текст-заполнитель Lorem ipsum) stri_rand_lipsum(nparagraphs = 2) ## [1] &quot;Lorem ipsum dolor sit amet, non, consectetur aliquam mollis velit accumsan condimentum sit sed. Eu dapibus habitant faucibus interdum vel? Libero amet lacus aliquam ac sit, porta? Leo leo dolor enim eu rutrum volutpat posuere, pulvinar, inceptos bibendum aliquam quis. Laoreet vulputate inceptos posuere eu, id vel pretium eu eu. Ut in urna ac laoreet scelerisque hendrerit. Metus integer purus nec, purus parturient dolor eget quis pharetra tristique. Donec in lacus vehicula orci, ligula faucibus per. Sem amet tempus nascetur, tincidunt euismod pellentesque sit? In vitae ligula nec pellentesque sed hac. Curabitur ut semper lectus justo ut suspendisse ut at faucibus dolor. Nec non neque senectus donec sit nunc. Urna sed, ultricies, ac pharetra orci luctus, iaculis ac.&quot; ## [2] &quot;Tincidunt cum neque eu semper at sociosqu hendrerit eu aliquet lacus, eu hendrerit. Donec aliquam eros risus nibh quam in sit facilisi ipsum. Amet sem sed donec sed molestie, scelerisque tincidunt nisl. Donec et facilisis interdum non sed dolor purus in ipsum, dignissim torquent velit. Nec aliquam pellentesque, ac adipiscing neque et at torquent. Vestibulum ullamcorper ad dictumst. Enim velit non nulla, felis habitant egestas placerat consectetur. Dictum nostra sed nec. Erat phasellus dolor libero aliquam viverra, vestibulum leo et suscipit. Egestas in in montes sapien gravida conubia purus varius ut nec. Feugiat, risus eleifend magnis neque diam suspendisse ullamcorper nulla adipiscing, malesuada massa nisi.&quot; встроенные векторы letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; чтение из файла Чтение таблицы Функция read_csv взята из пакета readr, который является частью tidyverse. Для чтения таблиц также есть функции read_csv2(), read_tsv() и read_delim(). В каких случаях они используются вы можете узнать в справке: ?read_csv2() sample &lt;- read_csv(&quot;data/data_ficbook_untamed_sample.csv&quot;) ## Warning: Missing column names filled in: &#39;X1&#39; [1] head(sample) Чтение текста Прочитать файл полностью можно с помощью функций из пакета readr: read_file() и read_lines(). NB! read_file() будет работать очень долго, если размер текста большой. my_file &lt;- read_file(&quot;data/Cox_Forshaw_WHy_E_equals_mc_squared_ocr.txt&quot;) my_file ## [1] &quot;ПОМI N1% /;\\r\\nIII г2’»\\r\\nпо\\tона может принимать разные\\r\\n„ труднее определить.\\t„„ происходило, общее к„.\\r\\nЭнергию Р&gt; тоЧНо очевиден.\\tаТЬСя неизменным не-\\r\\n,;.г,ои процессе\\tэмми №тер дала нам\\r\\nзависимо от изменения других\\tп&lt;)Т0Му, что законы физики\\r\\nглубокое объяснение. Энергия ^\\tутверЖде„ие не означает, что\\r\\nис изменяются с течением прем\\tосто бессмысленно. На самом\\r\\n„„чего не происходит - это Ьъ спрапедлипы сегодня, деле оно означает, что если уН»\\tВы можете заменить ело-\\r\\nто „ни должны быть 2»™Л;В“ла,, любым другим фундаментальным\\r\\nвосочетание «уравнения Максвелл\\tмер.\\r\\nзаконом физики-постулатами Эинште\\tимпульса, закон со-\\r\\nВместе с тем, как и в случае закона сохранения . У ^\\t„\\r\\nхранения энергии был открыт экспериментальным )\\t•\\r\\nоткрытия восходит к промышленной революции. Все началось с раоо эксиериментаторов-практиков, которые обнаружили множество с. „„четких и химических явлений в поисках промышленного Иерусалима-К числу таких людей относился и несчастный граф Румфорд Баварский (рожденный под именем Бенджамин Томпсон в Массачусетсе в 1753 году I, работа которого состояла в высверливании каналов в пушечных стволах для армии герцога Баварии. В процессе работы он обратил внимание, что металл пушечного ствола и сверло нагреваются, и справедливо предположил, что вращательное движение сверла превращается в тепло под воздействием трения. Это прямо противоположно тому, что происходит в паровом двигателе, где тепло преобразуется во вращательное движение колес поезда. Казалось вполне естественным связать некую общую величину с теплом и вращательным движением, поскольку, как выяснилось эти две на первый взгляд совершенно разные вещи взаимозаменяемы Эта величина - энергия. Румфорда называли несчастным, потому что\\r\\nон женился на вдове другого великого ученого, Антуана Л тш,-\\r\\n’\\t7 ,ав&gt;лзье, после\\r\\nтого как тот во время Французской революции сложил голову н » п\\r\\nтине. Румфорд ошибочно решил, что эта женщина будет делать дЛ},\\r\\nто же, что и для Лавуазье, прилежно записывая все результаты СГо *\\&quot; °\\r\\nботы и повинуясь ему, как полагалось хорошей жене в XVIII ст,„1СПи Но оказалось, она проявляла кроткость только под давлением железног\\r\\nра-\\r\\nолетиц.\\r\\nпо\\r\\n«ЕМ*\\r\\nЖ*\\r\\n(. тс*7\\r\\nII\\r\\n, л..у&gt;»&#39;- в св°ей ммеЧаТе\\&quot;ЬНОЙ книге 1 Ьс Оием Гог АЬзо1ц1с 2его-Мендельсон писал, что эта женщина превратила жизнь графа Ру„.\\r\\nВ1\\r\\nКУРТ\\r\\n„ „ яп Но главное не это, а то, что энергия всегда соуп™ ,\\r\\nхорда в ад-\\t_\\tг ^да сохраняется, имен-\\r\\n* п^тШу она вызывает такой интерес.\\r\\nяо ПОЭ 7\\r\\nПопросите кого-либо на улице объяснить, что такое энергия, -й получите либо осмысленный ответ, либо кучу всякого вздора в духе „ью-эйдж” В массовой культуре существует много разных значений слова «энергия», поскольку оно употребляется очень широко. Следует отметить, однако, что на самом деле есть точное определение энергии, которое нельзя использовать для объяснения лей-линий***, исцеления кристаллами, жизни после смерти или реинкарнации. Здравомыслящий человек мог бы сказать, что энергию можно хранить внутри аккумуляторной батареи, где она находится в состоянии ожидания до тех пор, пока кто-то не «замкнет цепь». Кто-то другой, возможно, возразит, что энергия — это показатель количества движения и что быстро движущиеся объекты обладают большей энергией, чем более медленные. Энергия, которую содержит море или ветер, — вот еще примеры определений. Вам могут также сказать, что горячие объекты содержат больше энергии, чем холодные. Гигантский маховик, который находится вн\\\\ три электростанции, может накапливать энергию, которая высвобожда ется затем в электросеть для удовлетворения потребностей населения в электроэнергии. Кроме того, энергия выделяется в процессе деления .томного ядра. Это только несколько примеров присутствия энергии в повседневной жизни. Во всех этих сяучаях физик,, могут представить\\r\\nгЬпоме и использовать эту информацию для энергию в количественной фор«\\t^\\t,ффеИ\\r\\nподведения\\t“менным общее количество энергии,\\r\\nлюбого процесса сохран\\r\\n--------------- Мендельсон К. А. Г. На пути к абсолютному нулю: Вве-\\r\\n* ИЗДаНЗ «&#39;у низких температур. М.: Атомиздат. 1971. пение в физику ”\\r\\nм\\t^\\tокупности различных мистических течении и движе-\\r\\nОбщее название со УгноГО, эзотерического и синкретического характера.\\r\\nНИЙ. В ОСНОВНОМ окк&gt;\\r\\nПрим, ред-\\t^ места на поверхности Земли, которым свойственно прояв-\\r\\n... Предположителен _ энеррии&gt;&gt; Прим авт_\\r\\nление\\r\\n112\\r\\nсохранения энергии в действу\\r\\n. . . .у-П 1\\\\|« 111\\r\\nДпя того чтобы увидеть закон сохр,,,.^...\\r\\nследпии раз вернемся к сталкивающимся билья &#39;\\r\\n-»\\&quot;«й из них обладает определенной\\t«ч-*\\r\\nтог\\r\\nв ПОС\\r\\nм\\r\\n:д.\\r\\nю№ 11\\t«***•«*з........,«* ««у»\\t««««^\\r\\n“;„Г«ое,о да»*&#39;»»\\&quot;&#39; Некого языка слоя., «кинетический. ^\\r\\nили возникающий вследствие яви*..,,\\r\\nделястся как «обусло\\r\\n— * и\\r\\nтермин. Ранее мы исходили из того, что д„а 111а^ ____стью и имеют одинаковую массу. Затем &lt;*,\\r\\nтак что это правильный\\t....\\r\\nс одинаковом скор0^ -^ ^ ^ с равной скоростью в проп\\r\\n— - -ал»* 11/ЭПЛ Г* ПТЧП !«!/&gt;.\\r\\nДВИЖУТСЯ С ОДИН» --- •\\r\\nсталкиваются и отскакивают И —■ ^ значите/1ЬНОЙ мере продиктова\\r\\nположных направлениях. .\\tтщательный анализ ситуации па\\r\\n.законом сохранения импульса. Б««™*\\tле\\r\\nзлоллет определить, что скорость движения шар\\r\\nнемного ...к. их скорости „о столкновения. Это объясняется темли\\r\\nчаек начальной энергии рассеялась во время столкновения. Наиболее\\r\\nочевидное рассеяние энергии — переход ее части в звук. Когда бильярд\\r\\nные шары сталкиваются друг с другом, они воздействуют на молек.\\r\\nвоздуха, и это возмущение достигает наших ушей. Таким образом, час:\\r\\nначальной энергии теряется, из-за чего у шаров после столкновения оста\\r\\nется меньше энергии. С точки зрения темы данной книги нам на само *\\r\\nделе не нужно знать, как измерить энергию во всех ее проявлениях, хот-\\r\\nфьрмул. кинетической энергии нал, „се же пригодится немного позже\\r\\nКаждый, кто изучал л средней школе физику, навсегда запомнил эту фор мулу, кинетическая энергия = в п\\tД запомнил ЭТ\\\\ ^ г\\r\\nвыразить в количественной ф„р2„е одним чисдТмТ ЧТ° ЭНЧ&gt;\\&quot;\\&quot;“ лмчество энергии в системе всегда о г .\\tТ“КЖе ЧТО ООЩсе\\r\\nА \\&quot;\\&quot;Ч\\&quot;- вернемся к нашему разговор’\\&quot; К&#39;иам*«\\&quot;ЫМ.\\r\\n‘ \\&quot; к&#39;1,4 1ве примера величины, котоиа\\tЫ \\&quot;Паи1 кониепцию импуль\\r\\nс гиер&#39;ией практическая польз. ймпу„ьёГ“й“*“*\\&quot;* “ектоР°М Наряд)\\r\\n&#39;Управлении движения о *НИз&gt; на юго-ВОСТо 5 СЧетУ вектор им\\r\\nсклонность разделять \\&quot;\\&quot;\\&quot; \\&quot;Рц1ы«У1ЧУЮ глав! \\&quot; &#39;\\&quot;\\&quot;Йом «РУ™ -Ипм-У«ныстрел^.Г:;;е^;Р»пст1........... лр^ «окаэшиГи.\\r\\n&#39; ““\\&quot;“‘■«ы» четыре ЭТО«6лУжде-\\r\\nНапРпвле„„ях\\r\\nч\\r\\n\\r\\nЖЕ *\\r\\n\\r\\nII .4\\r\\nПГ1\\r\\nнства-времени, в противном случае мы так и не сможем соста-лГнламеИтальные уравнения с учетом теории Эйнштейна. Позволь-■Г^овторнтв еще раз: фундаментальные уравнения должны включать г* ,я объекты, существующие в пространстве-времени, а не объекты, * ествующие отдельно в пространстве или во времени, поскольку ь^ъекты такого типа носят субъективный характер. Если вы помните, [в*размер объекта в пространстве, ни промежуток времени между двумя мбытиями нельзя отнести к категории величин, со значением которых\\r\\nсогласятся все без исключения. Именно это мы имеем в виду, утверждая, что такие объекты носят субъективный характер. Импульс также представляет собой вектор, направленный куда-то только в пространстве. Такое предубеждение против времени сеет семена его разрушения. Предве щает ли пространство-время крушение этого самого фундаментального из всех законов физики? Вновь открытая структура пространства-времени действительно сеет семена разрушения, но она указывает нам так же дальнейший путь: нам необходимо найти инвариантную величину, которая сможет занять место устаревшего трехмерного импульса. А вот и ключевой момент нашего повествования: такая величина существует Давайте внимательнее взглянем на трехмерный вектор импульса. На рис. 11 он представлен в виде стрелки, которая может отображать рас стояние, на которое откатывается шар, перемещаясь по столу*. Если опи-\\r\\nсывать ситуацию точнее, то предположим, что в полдень шар находи гем\\r\\nУ одного конца этой стрелки, а через две секунды — у другого. Если шар перемещается на сантиметр каждую секунду, тогда длина стрелки равна Двум сантиметрам. Получить вектор импульса не составляет проблем Он представляет собой стрелку, указывающую абсолютно в том же на\\r\\nправлении, что и на рис. 11, но ее длина другая и равна скорости нашего Шара (в данном случае один сантиметр в секунду), умноженной на его массу, которая составляет, к примеру, десять граммов. Физики сказали бы, что вектор импульса этого шара имеет длину десять грамм сантиметров в секунду (в краткой форме они записали бы это гак: 10 I&#39; • см/с). Здесь снова целесообразно ввести абстрактные символы, вместо юго чтобы\\r\\n■ В выборе шара нет ничего особенного. Вместо него можно было бы выбрать любой другой объект.\\r\\n&quot; 2.2 Количество символов Подсчет Аналогом функции nchar() из базового R в пакете stringr является функция str_length. NB! Эта функция может давать неверные значения, так как подсчитывает количество кодовых точек, используемых для кодирования символа. Чаще всего одному символу соответствует одна кодовая точка, но может быть и больше. str_length(c(&quot;Hello&quot;, &quot;&quot;, NA)) ## [1] 5 0 NA Также для подсчета количества знаков в строке можно использовать функцию str_count, которая позволяет также подсчитывать количество паттернов (об этом см. пункт о поиске подстроки ниже). Таблица tibble - аналог data.frame, используемый в библиотеке tidyverse. tibble(mn = month.name) %&gt;% mutate(n_charactars = str_count(mn)) Приведение к желаемому количеству Иногда нам нужно соклатить строку до определенного количества символов. Это легко сделать с помощью функции str_trinc(). Например, можно сократить количество знаков в строке до 6 (по умолчанию индикатор сокращения - ellipsis - это многоточие): tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, width=6)) Функция позволяет также изменить индикатор сокращения и определить, сокращаем мы строку за счет ее начала, середины или конца: tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6, ellipsis = &quot;-&quot;, side = &quot;left&quot;)) Обратная функция для “раздувания” строки - str_pad. По умолчанию это делается за счет пробелов \" \" tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10)) Аргументы аналогичны: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10, pad = &quot;.&quot;, side = &quot;both&quot;)) Для форматирования строки в соответствии с определенной шириной и отступами используют функцию str_wrap. Например, попрорбуем представить первый параграф Lorem ipsum в виде строк с шириной не более 30 знаков (без переноса слов) some_txt &lt;- stri_rand_lipsum(nparagraphs = 1) cat(str_wrap(some_txt, width = 30)) ## Lorem ipsum dolor sit ## amet, metus integer iaculis ## tincidunt ac orci convallis. ## Metus duis neque ligula ## natoque nostra vel montes ## fringilla. Efficitur arcu ## dolor vel et diam, tincidunt, ## rhoncus, ad donec. Rutrum ## mauris ornare suspendisse ## justo, vehicula id diam, ## mollis ut. Velit et eu, mauris ## nunc vestibulum sapien. Augue ## dignissim vulputate montes ## ipsum rutrum, eu, eu. Porta ## faucibus maximus ac fusce ## placerat. In imperdiet libero ## cum conubia lacus. Ornare ## tempor vel nam, pulvinar, ## imperdiet sit, vestibulum ## ipsum orci. Можно, например, указать отступ: cat(str_wrap(some_txt, width = 30, indent = 2), &quot;\\n&quot;) ## Lorem ipsum dolor sit ## amet, metus integer iaculis ## tincidunt ac orci convallis. ## Metus duis neque ligula ## natoque nostra vel montes ## fringilla. Efficitur arcu ## dolor vel et diam, tincidunt, ## rhoncus, ad donec. Rutrum ## mauris ornare suspendisse ## justo, vehicula id diam, ## mollis ut. Velit et eu, mauris ## nunc vestibulum sapien. Augue ## dignissim vulputate montes ## ipsum rutrum, eu, eu. Porta ## faucibus maximus ac fusce ## placerat. In imperdiet libero ## cum conubia lacus. Ornare ## tempor vel nam, pulvinar, ## imperdiet sit, vestibulum ## ipsum orci. Иногда в начале и/или конце строки присутствуют лишные пробелы, от которых нам хотелось бы избавиться. Для быстрого “отсечения” пробелов используют функцию str_trim(): raw_strings &lt;- c(&quot;Эта &quot;, &quot; строка &quot;, &quot;, &quot;, &quot; имеет&quot;, &quot; кучу&quot;, &quot; пробелов &quot;) #Можно указать, с какой стороны убирать пробелы str_trim(raw_strings, side = &quot;left&quot;) ## [1] &quot;Эта &quot; &quot;строка &quot; &quot;, &quot; &quot;имеет&quot; &quot;кучу&quot; &quot;пробелов &quot; #А можно убрать с обоих концов str_trim(raw_strings, side = &quot;both&quot;) ## [1] &quot;Эта&quot; &quot;строка&quot; &quot;,&quot; &quot;имеет&quot; &quot;кучу&quot; &quot;пробелов&quot; 2.3 Сортировка Вопрос выбора метода сортировки строк - не из самых простых. Алгоритмов сортировки существует множество, скорость их работы отличается в зависимости от формата данных и способа их хранения. Для выбора алгоритма следует учитывать два аспекта: скорость его работы и объем необходимой памяти. (с) [BigOcheatsheet] (https://www.bigocheatsheet.com/) Для расчета сложности алгоритмов используется О-нотация, которая, грубо говоря, оценивает скорость роста функции, описывающей работу этого алгоритма. (с) [BigOcheatsheet] (https://www.bigocheatsheet.com/) Стандартное время работы алгоритмов сортировки - O(nlogn), где n - это количество наблюдений (длина массива), однако для сортировки строк есть и более быстрые решения, например MSD radix sort, часто рекомендуемый для сортировки строк, со скоростью работы O(kn), где n - это количество наблюдений, а k - количество разрядов. Визуализацию работы популярных алгоритмов сортировки можно увидеть здесь. В этом видео можно узнать, как начать разбираться в алгоритмах, если вам интересно. Таким образом, для сортировки больших массивов строковых данных в базовом R можно использовать функцию sort() с указанием метода radix sort: sort(..., method = \"radix\") В пакете stringrдля сортировки есть функции str_sort и str_order. Встроенный алгоритм сортировки в них не изменить, но зато можно задать локаль. unsorted_strings &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;e&quot;, &quot;i&quot;, &quot;б&quot;, &quot;я&quot;) #english str_sort(unsorted_strings, locale = &quot;en&quot;) ## [1] &quot;a&quot; &quot;b&quot; &quot;ba&quot; &quot;e&quot; &quot;i&quot; &quot;б&quot; &quot;я&quot; #hawaiian str_sort(unsorted_strings, locale = &quot;haw&quot;) ## [1] &quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;b&quot; &quot;ba&quot; &quot;б&quot; &quot;я&quot; #default str_sort(unsorted_strings) ## [1] &quot;a&quot; &quot;b&quot; &quot;ba&quot; &quot;e&quot; &quot;i&quot; &quot;б&quot; &quot;я&quot; #ukranian str_sort(unsorted_strings, locale = &quot;ru_UA&quot;) ## [1] &quot;б&quot; &quot;я&quot; &quot;a&quot; &quot;b&quot; &quot;ba&quot; &quot;e&quot; &quot;i&quot; NB! Знайте локаль своего компьютера, от нее зависит порядок сортировки. Функция stringi::stri_locale_list() покажет вам список локалей на компьютере. Ознакомьтесь также с stringi::stri_locale_info и stringi::stri_locale_set 2.4 Конкатенация Конкатенация - это операция склеивания, сцепления. Функция str_c позволяет склеивать строки в одну строку. str_c(&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;) ## [1] &quot;hello&quot; Можно указать разделитель аргументом sep: str_c(&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, sep=&quot;_&quot;) ## [1] &quot;h_e_l_l_o&quot; NB! NA выскакивают как NA, а пустые строки опускаются. Чтобы NA превратить в строку используйте str_replace_na(): x &lt;- c(&quot;a&quot;, NA) str_c(&quot;префикс-&quot;, x, &quot;-суффикс&quot;) ## [1] &quot;префикс-a-суффикс&quot; NA str_c(&quot;префикс-&quot;, str_replace_na(x), &quot;-суффикс&quot;) ## [1] &quot;префикс-a-суффикс&quot; &quot;префикс-NA-суффикс&quot; Чтобы вектор строк превратить в одну строку воспользуйтесь аргументом collapse: x &lt;- c(&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;) str_c(x) ## [1] &quot;h&quot; &quot;e&quot; &quot;l&quot; &quot;l&quot; &quot;o&quot; str_c(x, collapse = &quot;_&quot;) ## [1] &quot;h_e_l_l_o&quot; Обратная операция - разделение строк. Для этого можно использовать функции separate() или str_split(). Используйте separate() для разбиения колонки из таблицы на несколько колонок head(sample) %&gt;% separate(col = author_link, into = c(&quot;column_1&quot;, &quot;column_2&quot;, &quot;author_id&quot;), sep = &quot;/&quot;) Для преобразование строки в список из разделенных строк используйте str_split(). Например, если нам нужно узнать домен почты: dummy_emails &lt;- c(&quot;andan@gmail.com&quot;, &quot;icedone@mail.ru&quot;, &quot;imdone@un.org&quot;) str_split(dummy_emails, &quot;@&quot;) ## [[1]] ## [1] &quot;andan&quot; &quot;gmail.com&quot; ## ## [[2]] ## [1] &quot;icedone&quot; &quot;mail.ru&quot; ## ## [[3]] ## [1] &quot;imdone&quot; &quot;un.org&quot; Кроме того, иногда вам может помочь функция str_split_fixed(), если у вас есть список строк, которые вам нужно разбить на части, у этих строк есть определенный паттерн, по которому они составлены, и вы всегда знаете, на сколько частей нужно эти строки разбить: dummy_books &lt;- c(&quot;1974_Carrie_Doubleday&quot;, &quot;1975_Salem&#39;s_lot_Doubleday&quot;, &quot;1977_The_Shining_Doubleday&quot;) #хотим список книг СМтивена Кингана 2 части str_split_fixed(dummy_books, pattern=&quot;_&quot;, n=2) ## [,1] [,2] ## [1,] &quot;1974&quot; &quot;Carrie_Doubleday&quot; ## [2,] &quot;1975&quot; &quot;Salem&#39;s_lot_Doubleday&quot; ## [3,] &quot;1977&quot; &quot;The_Shining_Doubleday&quot; Но это не всегда хорошо работает, поэтому существуют регулярные выражения: str_split_fixed(dummy_books, pattern=&quot;_&quot;, n=3) ## [,1] [,2] [,3] ## [1,] &quot;1974&quot; &quot;Carrie&quot; &quot;Doubleday&quot; ## [2,] &quot;1975&quot; &quot;Salem&#39;s&quot; &quot;lot_Doubleday&quot; ## [3,] &quot;1977&quot; &quot;The&quot; &quot;Shining_Doubleday&quot; 2.5 Работа с подстрокой Поиск подстроки Функция str_detect() ищет подстроку в строке и возвращает TRUE или FALSE: tibble(mn = month.name) %&gt;% mutate(has_r = str_detect(mn, &quot;r&quot;)) А функция str_which() возвращает индекс элесента, в котором есть совпадение с подстрокой, которую ищут: str_which(month.name, &quot;r&quot;) ## [1] 1 2 3 4 9 10 11 12 #фильтр по наличию подстроки tibble(mn = month.name) %&gt;% slice(str_which(mn, &quot;r&quot;)) Если нужно вернуть не индекс, а сам элемент, в котором есть подстрока, можно также использовать str_subset: str_subset(month.name, &quot;r&quot;) ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;September&quot; &quot;October&quot; ## [7] &quot;November&quot; &quot;December&quot; str_count() возвращает количество вхождений данной подстроки в строке: str_count(month.name, &quot;r&quot;) ## [1] 1 2 1 1 0 0 0 0 1 1 1 1 Также в зависимости от задачи, вам могут пригодиться функции str_locate() и str_locate_all() 2.6 Изменение строки Ну и самый сок, наиболее часто используемые функции связаны с преобразованием строк. Особенно популярны при “чистке” данных. Изменение регистра Все просто, для приведения всех букв к заглавным используется str_to_upper() str_to_upper(month.name) ## [1] &quot;JANUARY&quot; &quot;FEBRUARY&quot; &quot;MARCH&quot; &quot;APRIL&quot; &quot;MAY&quot; &quot;JUNE&quot; ## [7] &quot;JULY&quot; &quot;AUGUST&quot; &quot;SEPTEMBER&quot; &quot;OCTOBER&quot; &quot;NOVEMBER&quot; &quot;DECEMBER&quot; Чаще всего все буквы приводят к прописным: str_to_lower(month.name) ## [1] &quot;january&quot; &quot;february&quot; &quot;march&quot; &quot;april&quot; &quot;may&quot; &quot;june&quot; ## [7] &quot;july&quot; &quot;august&quot; &quot;september&quot; &quot;october&quot; &quot;november&quot; &quot;december&quot; Можно и так str_to_title(some_txt) ## [1] &quot;Lorem Ipsum Dolor Sit Amet, Metus Integer Iaculis Tincidunt Ac Orci Convallis. Metus Duis Neque Ligula Natoque Nostra Vel Montes Fringilla. Efficitur Arcu Dolor Vel Et Diam, Tincidunt, Rhoncus, Ad Donec. Rutrum Mauris Ornare Suspendisse Justo, Vehicula Id Diam, Mollis Ut. Velit Et Eu, Mauris Nunc Vestibulum Sapien. Augue Dignissim Vulputate Montes Ipsum Rutrum, Eu, Eu. Porta Faucibus Maximus Ac Fusce Placerat. In Imperdiet Libero Cum Conubia Lacus. Ornare Tempor Vel Nam, Pulvinar, Imperdiet Sit, Vestibulum Ipsum Orci.&quot; Выделение подстроки Выделить подстроку из строки можно, указав индексы (str_sub())… tibble(mn = month.name) %&gt;% mutate(mutate = str_sub(mn, start = 1, end = 3)) tibble(mn = month.name) %&gt;% mutate(mutate = str_sub(mn, start = -3, end = -1)) … или указав сам паттерн (подстроку) (str_extract()) tibble(mn = month.name) %&gt;% mutate(mutate = str_extract(mn, &quot;e&quot;)) Как видите, в некоторых словах несколько букв e, но функция возвратила лишь одну. Это потому что str_extract() возвращает только первое вхождение. Для того, чтобы вернуть все вхождения подстроки, используйте str_extract_all(). Вам вернется список. str_extract_all(month.name, &quot;e&quot;) ## [[1]] ## character(0) ## ## [[2]] ## [1] &quot;e&quot; ## ## [[3]] ## character(0) ## ## [[4]] ## character(0) ## ## [[5]] ## character(0) ## ## [[6]] ## [1] &quot;e&quot; ## ## [[7]] ## character(0) ## ## [[8]] ## character(0) ## ## [[9]] ## [1] &quot;e&quot; &quot;e&quot; &quot;e&quot; ## ## [[10]] ## [1] &quot;e&quot; ## ## [[11]] ## [1] &quot;e&quot; &quot;e&quot; ## ## [[12]] ## [1] &quot;e&quot; &quot;e&quot; &quot;e&quot; замена подстроки Функции str_replace() и str_replace_all() работают аналогично str_extract(), то есть первая заменчет только первое вхождение подстроки, а вторая заменяет все подстроки str_replace(&quot;September&quot;, &quot;e&quot;, &quot;E&quot;) ## [1] &quot;SEptember&quot; str_replace_all(&quot;September&quot;, &quot;e&quot;, &quot;E&quot;) ## [1] &quot;SEptEmbEr&quot; Удаление подстроки Аналогично работают str_remove() и str_remove_all() str_remove(&quot;September&quot;, &quot;e&quot;) ## [1] &quot;Sptember&quot; str_remove_all(&quot;September&quot;, &quot;e&quot;) ## [1] &quot;Sptmbr&quot; Транслитерация строк Пакет stringi позволяет производить транслитерацию строк. Методы можно посмотреть с помощью функции stri_trans_list() x &lt;- &quot;фанфик&quot; #транслитерация на английский - заметьте, не перевод stri_trans_general(x, &quot;cyrillic-latin&quot;) ## [1] &quot;fanfik&quot; #с английского на катакану stri_trans_general(&quot;fanfic&quot;, &quot;Latin-Katakana&quot;) ## [1] &quot;ファンフィク&quot; #с английского на хирагану stri_trans_general(&quot;fanfic&quot;, &quot;Latin-Hiragana&quot;) ## [1] &quot;ふぁんふぃく&quot; #с английского на хангыль stri_trans_general(&quot;fanfic&quot;, &quot;Latn-Hang&quot;) ## [1] &quot;판핓&quot; 2.7 Пакеты для работы с текстовыми данными -определение языка -расстояние между строками -stylo -ner (extract names) 2.8 Задания Итак Задание 1 Представьте, что у вас есть оцифрованный текст (тот, что вы уже загрузили в my_file). Вам необходимо произвести его очистку, пока что теми средствами, что вы успели изучить. Этот текст - отрывок из книги Брайаня Кокса и Джеффа Форшоу “Что такое E=mc^2 и зачем нам это знать.” Текст на русском, почти не содержит формул(=ими можно пренебречь). в нем есть сноски и заголовки. my_file ## [1] &quot;ПОМI N1% /;\\r\\nIII г2’»\\r\\nпо\\tона может принимать разные\\r\\n„ труднее определить.\\t„„ происходило, общее к„.\\r\\nЭнергию Р&gt; тоЧНо очевиден.\\tаТЬСя неизменным не-\\r\\n,;.г,ои процессе\\tэмми №тер дала нам\\r\\nзависимо от изменения других\\tп&lt;)Т0Му, что законы физики\\r\\nглубокое объяснение. Энергия ^\\tутверЖде„ие не означает, что\\r\\nис изменяются с течением прем\\tосто бессмысленно. На самом\\r\\n„„чего не происходит - это Ьъ спрапедлипы сегодня, деле оно означает, что если уН»\\tВы можете заменить ело-\\r\\nто „ни должны быть 2»™Л;В“ла,, любым другим фундаментальным\\r\\nвосочетание «уравнения Максвелл\\tмер.\\r\\nзаконом физики-постулатами Эинште\\tимпульса, закон со-\\r\\nВместе с тем, как и в случае закона сохранения . У ^\\t„\\r\\nхранения энергии был открыт экспериментальным )\\t•\\r\\nоткрытия восходит к промышленной революции. Все началось с раоо эксиериментаторов-практиков, которые обнаружили множество с. „„четких и химических явлений в поисках промышленного Иерусалима-К числу таких людей относился и несчастный граф Румфорд Баварский (рожденный под именем Бенджамин Томпсон в Массачусетсе в 1753 году I, работа которого состояла в высверливании каналов в пушечных стволах для армии герцога Баварии. В процессе работы он обратил внимание, что металл пушечного ствола и сверло нагреваются, и справедливо предположил, что вращательное движение сверла превращается в тепло под воздействием трения. Это прямо противоположно тому, что происходит в паровом двигателе, где тепло преобразуется во вращательное движение колес поезда. Казалось вполне естественным связать некую общую величину с теплом и вращательным движением, поскольку, как выяснилось эти две на первый взгляд совершенно разные вещи взаимозаменяемы Эта величина - энергия. Румфорда называли несчастным, потому что\\r\\nон женился на вдове другого великого ученого, Антуана Л тш,-\\r\\n’\\t7 ,ав&gt;лзье, после\\r\\nтого как тот во время Французской революции сложил голову н » п\\r\\nтине. Румфорд ошибочно решил, что эта женщина будет делать дЛ},\\r\\nто же, что и для Лавуазье, прилежно записывая все результаты СГо *\\&quot; °\\r\\nботы и повинуясь ему, как полагалось хорошей жене в XVIII ст,„1СПи Но оказалось, она проявляла кроткость только под давлением железног\\r\\nра-\\r\\nолетиц.\\r\\nпо\\r\\n«ЕМ*\\r\\nЖ*\\r\\n(. тс*7\\r\\nII\\r\\n, л..у&gt;»&#39;- в св°ей ммеЧаТе\\&quot;ЬНОЙ книге 1 Ьс Оием Гог АЬзо1ц1с 2его-Мендельсон писал, что эта женщина превратила жизнь графа Ру„.\\r\\nВ1\\r\\nКУРТ\\r\\n„ „ яп Но главное не это, а то, что энергия всегда соуп™ ,\\r\\nхорда в ад-\\t_\\tг ^да сохраняется, имен-\\r\\n* п^тШу она вызывает такой интерес.\\r\\nяо ПОЭ 7\\r\\nПопросите кого-либо на улице объяснить, что такое энергия, -й получите либо осмысленный ответ, либо кучу всякого вздора в духе „ью-эйдж” В массовой культуре существует много разных значений слова «энергия», поскольку оно употребляется очень широко. Следует отметить, однако, что на самом деле есть точное определение энергии, которое нельзя использовать для объяснения лей-линий***, исцеления кристаллами, жизни после смерти или реинкарнации. Здравомыслящий человек мог бы сказать, что энергию можно хранить внутри аккумуляторной батареи, где она находится в состоянии ожидания до тех пор, пока кто-то не «замкнет цепь». Кто-то другой, возможно, возразит, что энергия — это показатель количества движения и что быстро движущиеся объекты обладают большей энергией, чем более медленные. Энергия, которую содержит море или ветер, — вот еще примеры определений. Вам могут также сказать, что горячие объекты содержат больше энергии, чем холодные. Гигантский маховик, который находится вн\\\\ три электростанции, может накапливать энергию, которая высвобожда ется затем в электросеть для удовлетворения потребностей населения в электроэнергии. Кроме того, энергия выделяется в процессе деления .томного ядра. Это только несколько примеров присутствия энергии в повседневной жизни. Во всех этих сяучаях физик,, могут представить\\r\\nгЬпоме и использовать эту информацию для энергию в количественной фор«\\t^\\t,ффеИ\\r\\nподведения\\t“менным общее количество энергии,\\r\\nлюбого процесса сохран\\r\\n--------------- Мендельсон К. А. Г. На пути к абсолютному нулю: Вве-\\r\\n* ИЗДаНЗ «&#39;у низких температур. М.: Атомиздат. 1971. пение в физику ”\\r\\nм\\t^\\tокупности различных мистических течении и движе-\\r\\nОбщее название со УгноГО, эзотерического и синкретического характера.\\r\\nНИЙ. В ОСНОВНОМ окк&gt;\\r\\nПрим, ред-\\t^ места на поверхности Земли, которым свойственно прояв-\\r\\n... Предположителен _ энеррии&gt;&gt; Прим авт_\\r\\nление\\r\\n112\\r\\nсохранения энергии в действу\\r\\n. . . .у-П 1\\\\|« 111\\r\\nДпя того чтобы увидеть закон сохр,,,.^...\\r\\nследпии раз вернемся к сталкивающимся билья &#39;\\r\\n-»\\&quot;«й из них обладает определенной\\t«ч-*\\r\\nтог\\r\\nв ПОС\\r\\nм\\r\\n:д.\\r\\nю№ 11\\t«***•«*з........,«* ««у»\\t««««^\\r\\n“;„Г«ое,о да»*&#39;»»\\&quot;&#39; Некого языка слоя., «кинетический. ^\\r\\nили возникающий вследствие яви*..,,\\r\\nделястся как «обусло\\r\\n— * и\\r\\nтермин. Ранее мы исходили из того, что д„а 111а^ ____стью и имеют одинаковую массу. Затем &lt;*,\\r\\nтак что это правильный\\t....\\r\\nс одинаковом скор0^ -^ ^ ^ с равной скоростью в проп\\r\\n— - -ал»* 11/ЭПЛ Г* ПТЧП !«!/&gt;.\\r\\nДВИЖУТСЯ С ОДИН» --- •\\r\\nсталкиваются и отскакивают И —■ ^ значите/1ЬНОЙ мере продиктова\\r\\nположных направлениях. .\\tтщательный анализ ситуации па\\r\\n.законом сохранения импульса. Б««™*\\tле\\r\\nзлоллет определить, что скорость движения шар\\r\\nнемного ...к. их скорости „о столкновения. Это объясняется темли\\r\\nчаек начальной энергии рассеялась во время столкновения. Наиболее\\r\\nочевидное рассеяние энергии — переход ее части в звук. Когда бильярд\\r\\nные шары сталкиваются друг с другом, они воздействуют на молек.\\r\\nвоздуха, и это возмущение достигает наших ушей. Таким образом, час:\\r\\nначальной энергии теряется, из-за чего у шаров после столкновения оста\\r\\nется меньше энергии. С точки зрения темы данной книги нам на само *\\r\\nделе не нужно знать, как измерить энергию во всех ее проявлениях, хот-\\r\\nфьрмул. кинетической энергии нал, „се же пригодится немного позже\\r\\nКаждый, кто изучал л средней школе физику, навсегда запомнил эту фор мулу, кинетическая энергия = в п\\tД запомнил ЭТ\\\\ ^ г\\r\\nвыразить в количественной ф„р2„е одним чисдТмТ ЧТ° ЭНЧ&gt;\\&quot;\\&quot;“ лмчество энергии в системе всегда о г .\\tТ“КЖе ЧТО ООЩсе\\r\\nА \\&quot;\\&quot;Ч\\&quot;- вернемся к нашему разговор’\\&quot; К&#39;иам*«\\&quot;ЫМ.\\r\\n‘ \\&quot; к&#39;1,4 1ве примера величины, котоиа\\tЫ \\&quot;Паи1 кониепцию импуль\\r\\nс гиер&#39;ией практическая польз. ймпу„ьёГ“й“*“*\\&quot;* “ектоР°М Наряд)\\r\\n&#39;Управлении движения о *НИз&gt; на юго-ВОСТо 5 СЧетУ вектор им\\r\\nсклонность разделять \\&quot;\\&quot;\\&quot; \\&quot;Рц1ы«У1ЧУЮ глав! \\&quot; &#39;\\&quot;\\&quot;Йом «РУ™ -Ипм-У«ныстрел^.Г:;;е^;Р»пст1........... лр^ «окаэшиГи.\\r\\n&#39; ““\\&quot;“‘■«ы» четыре ЭТО«6лУжде-\\r\\nНапРпвле„„ях\\r\\nч\\r\\n\\r\\nЖЕ *\\r\\n\\r\\nII .4\\r\\nПГ1\\r\\nнства-времени, в противном случае мы так и не сможем соста-лГнламеИтальные уравнения с учетом теории Эйнштейна. Позволь-■Г^овторнтв еще раз: фундаментальные уравнения должны включать г* ,я объекты, существующие в пространстве-времени, а не объекты, * ествующие отдельно в пространстве или во времени, поскольку ь^ъекты такого типа носят субъективный характер. Если вы помните, [в*размер объекта в пространстве, ни промежуток времени между двумя мбытиями нельзя отнести к категории величин, со значением которых\\r\\nсогласятся все без исключения. Именно это мы имеем в виду, утверждая, что такие объекты носят субъективный характер. Импульс также представляет собой вектор, направленный куда-то только в пространстве. Такое предубеждение против времени сеет семена его разрушения. Предве щает ли пространство-время крушение этого самого фундаментального из всех законов физики? Вновь открытая структура пространства-времени действительно сеет семена разрушения, но она указывает нам так же дальнейший путь: нам необходимо найти инвариантную величину, которая сможет занять место устаревшего трехмерного импульса. А вот и ключевой момент нашего повествования: такая величина существует Давайте внимательнее взглянем на трехмерный вектор импульса. На рис. 11 он представлен в виде стрелки, которая может отображать рас стояние, на которое откатывается шар, перемещаясь по столу*. Если опи-\\r\\nсывать ситуацию точнее, то предположим, что в полдень шар находи гем\\r\\nУ одного конца этой стрелки, а через две секунды — у другого. Если шар перемещается на сантиметр каждую секунду, тогда длина стрелки равна Двум сантиметрам. Получить вектор импульса не составляет проблем Он представляет собой стрелку, указывающую абсолютно в том же на\\r\\nправлении, что и на рис. 11, но ее длина другая и равна скорости нашего Шара (в данном случае один сантиметр в секунду), умноженной на его массу, которая составляет, к примеру, десять граммов. Физики сказали бы, что вектор импульса этого шара имеет длину десять грамм сантиметров в секунду (в краткой форме они записали бы это гак: 10 I&#39; • см/с). Здесь снова целесообразно ввести абстрактные символы, вместо юго чтобы\\r\\n■ В выборе шара нет ничего особенного. Вместо него можно было бы выбрать любой другой объект.\\r\\n&quot; Имеет смысл разделить текст на параграфы по переносу строки \\n \\r\\n. Это можно сделать с помощью str_split(). Не забудьте экранировать специальные символы! Приведите все строки к нижнему регистру. Необходимо избавиться от лишних табуляций \\t и символов. Это текст на русском языке, нам же не нужны символы латинского алфавита? Лишние можно просто удалить или заменить на пробел. Вы точно удалили все ненужные символы? Составьте сортированный список всех символов. Это можно сделать, временно склеив обратно в единый текст все параграфы. Потом с помощью str_split() разделить все знаки по пустой строке \"“. У вас получится список, переделайте его в вектор! Из вектора можно составить таблицу частотности символов, а из нее вытащить список названий строк и отсортировать его. NB! Не удаляйте символ переноса строки”-\", если хотите сделать п.6. Проверьте длину строк. У вас есть пустые строки? Если есть, их можно удалить. 6*. Задание со звездочкой, выполнение опционально. Теперь надо разобраться с переносами строк, которые есть в печатных книгах, но нет в электронных текстах. Можно использовать цикл if: если предыдущая строка оканчивается на “-,” то создай новую строку, склеенную из предыдущей и этой. В противном случае, создай новую строку из предыдущей и этой, разделенную пробелом. Не забудьте обработать крайние значения (первая и последняя строки). Задание 2 Подготовим наши таблицы с фанфиками к обработке. sample %&gt;% print() ## # A tibble: 1,000 x 10 ## X1 link title author_link author page fandom subtitle text likes ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 /read… Сгорая… /authors/17… Mrs. … 63 Неукр… Подкидыш &quot;Осенн… 27 ## 2 2 /read… Объять… /authors/10… Wales 131 Неукр… &lt;NA&gt; &quot;На&lt;U+… 864 ## 3 3 /read… Волосы… /authors/51… Night… 1 Неукр… Введение &quot;Миг з… 47 ## 4 4 /read… Провер… /authors/38… Cold-… 52 Неукр… Семья &quot;На ут… 260 ## 5 5 /read… Поменя… /authors/57… Aiky 4 Неукр… Глава 9 … &quot;r / A… 282 ## 6 6 /read… Пепел … /authors/39… Sh.R 79 Неукр… Вместо э… &quot;— Так… 213 ## 7 7 /read… Собств… /authors/14… Aquam… 86 Неукр… Глава 15… &quot;Когда… 587 ## 8 8 /read… И тёмн… /authors/45… Notyo… 96 Неукр… &lt;NA&gt; &quot;Что е… 29 ## 9 9 /read… Я буду… /authors/54… Trish… 20 Неукр… Часть 72 &quot;Сичен… 357 ## 10 10 /read… Мальчи… /authors/19… Lorie 33 Неукр… Гарри По… &quot;Планы… 3141 ## # … with 990 more rows Посмотрите на столбец authors_link. Нам же не нужен рудимент \" /authors/\", оставшийся после скрэппинга? Удалите его. ID автора гораздо легче использовать, чем его полный никнейм. Но у нас разное количество символов в ID. Нужно привести их к общей схеме, расширив строку до максимальной длины с помощью нулей, которые нужно вставить в начало строки. Аналогичные манипуляции предлагаю проделать с ID работы из графы “link” 4*. Задание со звездочкой, выполнение опционально. Посмотрите на графу subtitle. Очевидно, у нас скачались отдельные главы фанфиков как отдельные фанфики. Нехорошо. Но! У нас также есть сборники фичков, которые и должны рассматриваться как отдельные фанфики (см. п. 13). Чем они отличаются? Наверное, наличием символов \"/\", \"\\\" или \"|\" в графе subtitle. Попробуйте соединить те тексты фичков, у которых совпадает ID и отсутствуют вышеперечисленные символы в названии. Количество лайков и страниц указывается для всего фанфика, а не для каждой главы, так что их можете не трогать. 2.9 Sources https://www.gastonsanchez.com/Handling_and_Processing_Strings_in_R.pdf https://agricolamz.github.io/DS_for_DH/ "],["strings2.html", "3 Регулярные выражения 3.1 Регулярные выражения", " 3 Регулярные выражения 3.1 Регулярные выражения 3.1.1 Паттерны В примерах к функциям gsub() и regexpr() мы упоминали и применяли особые конструкции, которые используются при обработке строковых данных - регулярные выражения. Регулярные выражения (англ. Regular Expressions, regexps)- это специальный язык для описания шаблонов строк, который используется для поиска определенных строк, проверки их на соответствие какому-либо шаблону и другой подобной работы. В функци gsub() и regexpr() мы как раз искали необходимые нам части строк с помощью паттернов (шаблонов), написанных в виде регулярнх выражений. Реализация регэкспов в разных языках программирования может различаться, в R используется расширенная версия регулярных выражений (ERE, стандарт POSIX 1003.2) с некоторыми собственными дополнениями, а так же Perl-совместимые регулярные выражения (PCRE 8.36). Согласно стандарту POSIX 1003.2, длина регулярных выражений не может превышать 256 байтов. Впрочем, как показывает практика, с таким ограничением мало кто сталкивается в своей работе. С регулярными выражениями есть, к сожалению, одна достаточно неприятная особенность - если выражение написано неправильно (в частности, при использовании метасимволов), то в результате, в зависимости от контекста использования, будет либо пропуск нужных элементов, либо просто отсутствие какого-либо эффекта. Поэтому есть смысл упрощать работу с регулярными выражениями, особенно если нет достаточного опыта их использования. Например, разбивать делать изменение части строки в несколько этапов, или же просто тестировать регулярные выражения небольшими блоками. 3.1.2 Символы В большинстве своем символы в регулярных выражениях обозначают сами себя, за некоторыми исключениями. Каждый символ в паттерне задает соответствие только одному символу в строке, поэтому в тех случаях, когда необходимо указать какой-то символ из определенного набора или указать, что какой-то символ повторяется некоторое количество раз подряд, следует использовать символьные классы или квантификаторы соответственно. В R ряд функций для поиска и замены строк по паттерну имеют две версии - первая обрабатывает только первоей найденное значение, соответствующее паттерну, вторая версия - все найденные по паттерну значения. Например, функция sub() находит и заменяет первое вхождение искомого символа, gsub - все вхождения: # задаем строку my_string &lt;- &#39;mystring998989&#39; # удаляем символ 9, первое вхождение sub(&#39;9&#39;, &quot;&quot;, my_string) [1] &quot;mystring98989&quot; # удаляем все символы `9` с помощью функции gsub() gsub(&#39;9&#39;, &quot;&quot;, my_string) [1] &quot;mystring88&quot; Если в паттерне указать несколько символов, то поиск по строке будет произведен именно по такому сочетанию символов. Например, удалим из строки (заменим на пустую строку) сочетание 89: # удаляем сочетание символов 89, первое вхождение sub(&#39;89&#39;, &quot;&quot;, my_string) [1] &quot;mystring9989&quot; # удаляем сочетание символов 89, все вхождения gsub(&#39;89&#39;, &quot;&quot;, my_string) [1] &quot;mystring99&quot; Следует учитывать, что некоторые символы или сочетания символов могут быть проинтерпретированы либо как управляющие конструкции регулярных выражений (см. #text_metacharacters) и тогда потребуются дополнительные указания, как должны быть обработаны эти символы. Во-вторых, некоторые группы символов могут просто иметь дополнительные фиксированные значения. Так, для кодирования перехода на новую строку, табуляции и некоторых других непечатаемых символов используются определенные обозначения: \\n, \\r, \\t, \\v, \\f. Соответственно, если в строке встретится какое-то из этих сочетаний, то строка будет прочитана и обработана не как строка, содержащая символы обратного слеша и буквы, а как строка с спец.символом (в случае с табуляцией - \\t): string_with_tab &lt;- &#39;metachara\\tcters&#39; cat(string_with_tab) metachara cters # пробуем удалить из строку букву t gsub(&#39;t&#39;, &#39;_DELETED_&#39;, string_with_tab) [1] &quot;me_DELETED_achara\\tc_DELETED_ers&quot; Подобные символы, тем не менее, можно обрабатывать как и все прочие: gsub(&#39;\\t&#39;, &#39;_DELETED_&#39;, string_with_tab) [1] &quot;metachara_DELETED_cters&quot; 3.1.3 Классы символов Задачи на поиск конкретного символа с помощью регулярных выражений встречаются, но, в целом, стоит признать, что обычно требуется большая гибкость поиска. Например, не конкретный символ или сочетание символов, а какой-либо символ из набора - знаки пунктуации или же цифры. Cамостоятельно указать какой-то набор символов с помощью квадратных скобок (стоит помнить, что квадратные скобки как метасимволы регулярных выражений и квадратные скобки в R - это разные конструкции). При этом можно либо просто перечислить все символы набора, либо, если они принадлежат какому-то известному множеству (например, цифры), то указать первый и последний элементы множества через знак дефиса (-). Также можно сочетать сокращенные формы записи наборов символов. Символы кириллического и латинского алфавитов - разные множества, точно также как строчные и прописные буквы. Внутри классов поведение метасимволов может различаться в зависимости от места их указания в наборе символов класса. Например, ^ первым символов в наборе символов задает логическое отрицание не из этих символов, и чтобы избежать такого поведения, знак ^ надо поставить на любое место кроме первого в цепочке. Знак ], если есть необходимость его вкючения в набор символов, наоборот, надо ставить первым в наборе, в противном случае он будет проинтерпретирован как завершение класса. Знак -, если указан не первым и не последним, интерпретируется как знак интервала в известном диапазоне символов (например, [0-9] означает от 0 до 9, а [09-] - символы 0, 9 и -) # задаем строку my_string &lt;- &#39;D9586bNd879мрЯпп&#39; # укажем, что удалить надо любую из цифр gsub(&#39;[0123456789]&#39;, &#39;&#39;, my_string) [1] &quot;DbNdмрЯпп&quot; gsub(&#39;[0-9]&#39;, &#39;&#39;, my_string) [1] &quot;DbNdмрЯпп&quot; # удаляем цифры, а так же строчные буквы кириллицы и латиницы gsub(&#39;[0-9a-zа-я]&#39;, &#39;&#39;, my_string) [1] &quot;DNЯ&quot; 3.1.3.1 Символьные классы в POSIX Стандарт POSIX 1003.2 поддерживает несколько определенных обозначения для часто используемых символьных классов: [:alnum:]: все буквы и цифры, сочетание символьных классов [:alpha:] и [:digit:]. [:alpha:]: буквы алфавита в обоих регистрах, для прописных и строчных букв есть отдельные символьные классы: [:lower:] и [:upper:]. [:punct:]: знаки пунктуации, !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~.. [:digit:]: арабские цифры 0123456789. [:xdigit:]: цифры в шестнадцатеричном формате, 0123456789ABCDEFabcdef. [:graph:]: графические знаки, объединенный класс, состоящий из классов [:alnum:] и [:punct:]. [:print:]: печатаемые знаки, класс [:graph:], дополненный пробелом. [:blank:]: непечатаемые символы (пробел, знак табуляции, в зависимости от локали - неразрывный пробел и возможные другие непечатаемые символы). [:cntrl:]: управляющие символы (в таблицах символов ANSCII коды 000-031 и 121 в десятичной, 000-037 и 177 в восьмеричной системе, 000-07F в шестнадцатеричной системах счислений) [:space:]: некоторые управляющие символы, которые используются для создания разрывов между символами - пробел, переход на новую строку, возврат каретки, перевод страницы и т.д. В зависимости от локали может содержать дополнительные знаки. При указании символьного класса с помощью его имени надо помнить, что обозначение класса также заключается в []. То есть, вместо [:digit:] (обозначение класса) надо использовать [[:digit:]] (указание символьного класса в рег.выражении): gsub(&#39;[[:digit:]]&#39;, &#39;&#39;, my_string) [1] &quot;DbNdмрЯпп&quot; 3.1.3.2 Дополнительные символьные классы Помимо обозначений символьных классов, которые поддерживаются стандартом POSIX, также в R реализован ряд собственных символьных классов, которые, как правило, обозначают наиболее часто используемые комбинации: \\\\d: цифры, аналогично [0-9] \\\\D: не цифры, обратно \\\\d, аналогично [^0-9] \\\\w: символы, которые используются в письме, аналогично [A-z0-9_] \\\\W: обратный \\\\w набор, символы, которые не используются в письме \\\\S: все знаки, кроме пробела. Аналогично [^[:space:]] или [^\\\\s] # задаем строку my_string &lt;- &#39;D9586bNd879мрЯпп&#39; # удаляем все цифры с помощью класса [0-9] gsub(&#39;[0-9]&#39;, &#39;&#39;, my_string) [1] &quot;DbNdмрЯпп&quot; # удаляем все цифры с помощью класса [:digit:] gsub(&#39;[[:digit:]]&#39;, &#39;&#39;, my_string) [1] &quot;DbNdмрЯпп&quot; # удаляем все цифры с помощью класса \\\\d gsub(&#39;\\\\d&#39;, &#39;&#39;, my_string) [1] &quot;DbNdмрЯпп&quot; 3.1.4 Метасимволы Ряд символов имеет дополнительное значение - эти символы используются не только сами по себе, но и как определенные конструкции языка регулярных выражений. В частности, это символ [, который используется для создания произвольного символьного класса. Полный список выглядит следующим образом: .: подстановочный знак (wildcard), используется в тех случаях, когда необходимо указать, что на этом месте может быть любой знак \\: используется для экранирования метасимволов | : логический оператор или ( и ): используются для указания групп символов [: вместе с ] используется для указания символьных классов ^: якорь, указывающий на начало строки, а так же логический оператор отрицания, используемый в символьных классах $: якорь, указывающий на конец строки *, + и ? - квантификаторы, указывающие, что предыдущий символ или группа символов могут или должны повториться некоторое количество раз {: вместе с } исползуется как квантификатор, указывающий конкретное количество повторений предыдущего символа или группы символов &lt; и &gt;: используется в Perl-совместимых регулярных выражениях Для того, чтобы эти метасимволы воспринимались не как элементы языка регулярных выражений, а как есть, их необходимо экранировать двумя символами \\\\. Необходимость в двух символах \\\\ для экранирования возникает из-за того, что строковая запись регулярного выражения в R и собственно выражение на языке регулярных выражений несколько различаются. В частности, интерпретатор R также воспринимает обратный слеш как символ экранирования: string_with_escapes &lt;- c(&#39;\\\\a&#39;, &#39;\\\\z&#39;, &#39;\\\\&#39;) writeLines(string_with_escapes) \\a \\z \\ Таким образом, если мы хотим удалить из строки символы, которые могут быть проинтерпретированы как управляющие конструкции на языке регулярных выражений, мы должны либо экранировать эти символы двумя обратными слешами \\\\, либо в функции, использующей регулярное выражение, задавать аргумент fixed = TRUE): # пробуем удалить символы .* без экранирования gsub(&#39;.*&#39;, &#39;_DELETED_&#39;, &#39;metachara.*cters&#39;) [1] &quot;_DELETED_&quot; # пробудем удалить с экранированием каждого символа gsub(&#39;\\\\.\\\\*&#39;, &#39;_DELETED_&#39;, &#39;metachara.*cters&#39;) [1] &quot;metachara_DELETED_cters&quot; # используем аргумент fixed = TRUE, чтобы воспринимать паттерн не как регулярное выражение gsub(&#39;.*&#39;, &#39;_DELETED_&#39;, &#39;metachara.*cters&#39;, fixed = TRUE) [1] &quot;metachara_DELETED_cters&quot; 3.1.5 Логические операции В регулярных выражениях логические операции представлены в достаточно ограниченном виде, можно даже сказать, крайне бедно. Наиболее очевидная из существующих операции - это ИЛИ, когда надо задать несколько вариантов комбинаций символов. В частности, это крайне полезный инструмент для фильтрации вектора строковых значений по определенному критерию. Например, регулярными выражениями с логическим оператором можно просто выделить из списка логов те файлы, которые были созданы в 2015-2016 годах: models &lt;- c(&#39;log_2014.csv&#39;, &#39;log_2015.csv&#39;, &#39;log_2016.csv&#39;, &#39;log_2017.csv&#39;, &#39;log_2018.csv&#39;) models[grep(&#39;2015|2016&#39;, models)] [1] &quot;log_2015.csv&quot; &quot;log_2016.csv&quot; Второй логический оператор - ^, используется в тех случаях, когда надо исключить символы определенного класса. Следует помнить, что ^ используется в этом значении сугубо внутри [], в противном случае будет интерпретироваться в другом значении. # заменяем на &#39;_&#39; любой из символов d, e, f gsub(&#39;[def]&#39;, &#39;_&#39;, &#39;fadbcdefghe&#39;) [1] &quot;_a_bc___gh_&quot; # заменяем на &#39;_&#39; все, кроме символов d, e, f gsub(&#39;[^def]&#39;, &#39;_&#39;, &#39;fadbcdefghe&#39;) [1] &quot;f_d__def__e&quot; 3.1.6 Квантификаторы Для того, чтобы в паттерне указать, что какой-то символ или группа символов может повторяться, используют специальные управляющие знаки - квантификаторы: ?: предыдущий символ или группа символов в паттерне может встречаться 0 или 1 раз. Также вместе с другими квантификаторами используется для нежадного поиска. *: предыдущий символ или группа символов в паттерне может встречаться 0 или больше раз. +: предыдущий символ или группа символов в паттерне может встречаться 1 или больше раз. {n}: предыдущий символ или группа символов может встречаться в паттерно строго n раз. {n,}: предыдущий символ или группа символов может встречаться в паттерно n и более раз. Конструкции {0,} и {1,} тождественны * и + соответственно. {n,m}: предыдущий символ или группа символов может встречаться в паттерно n раз, но не более, чем m раз. Конструкции {0,1} и ? тождественны. Простейший пример использования квантификаторов - когда надо обработать какой-то символ, который встречается несколько раз. Например, скрыть последние четыре цифры в номере телефона: phone_number &lt;- &#39;my phone number: +7-929-138-5896&#39; gsub(&#39;[0-9]{4}&#39;, &#39;XXXX&#39;, phone_number) [1] &quot;my phone number: +7-929-138-XXXX&quot; 3.1.7 Подстановочные знаки Подстановочные знаки используются в тех ситуациях, когда надо просто указать, что в этом месте может быть любой символ. Несмотря на множественное число (wildcards), в регулярных выражениях в качестве подстановочного знака используется только метасимвол ., который обозначает любой знак. Обычно подстановочный знак используется в сочетании с квантификаторами, указывающими, что в этом месте может быть любое количество символов. Например, использование подстановочных знаков может помочь строку, из которой известно только несколько символов. Попробуем из списка строк выбрать только адреса электронной почты в домене ru, исходя из предположения, что требуемые адреса содержат знак @ и сочетание .ru: emails &lt;- c(&#39;myemail@yahoo.com&#39;, &#39;id638@yandex.ru&#39;, &#39;simple string&#39;, &#39;lizzy@mail.ru&#39;, &#39;pumpkinpie@gmail.com&#39;) emails[grep(&#39;@.+\\\\.ru&#39;, emails)] [1] &quot;id638@yandex.ru&quot; &quot;lizzy@mail.ru&quot; 3.1.8 Якори Якори используются для обозначения, что сочетание символов в паттерне обязательно должно начинать или завершать строку. Также есть якори, которые маркируют начало или конец не строки, а слова, однако само определение слова зависит от используемой локали. В R используются следующие якори: ^ и $: начало и конец строки соответственно \\\\&lt; и \\\\&gt;: начало и конец слова \\\\b: пустая строка или края слова \\\\B: не край слова Простым примером может быть выбор и чтение только xls-файлов, с игнорированием xlsx-файлов или прочих файлов в папке. Так же при импорте файлов MS Office нередко приходится игнорировать еще и временные файлы, которые создаются при работе с файлом MS Office и обычно скрыты от пользователя (их можно отличить по символам ~$ в начале назания файла). Для этого надо указать, что в начале названия строки нет маркеров временных файлов или что название файла начинается с требуемого буквосочетания. Так же надо указать, что файл заканчивается строго на xls. Символы в названии, которые находятся между символами, используемыми в начале и конце строки, можно задать с помощью подстановочного знака и квантификатора (.*): files &lt;- c(&#39;report_2018.xlsx&#39;, &#39;report2017.xlsx&#39;, &#39;~$report2016.xls&#39;, &#39;report2016.xls&#39;, &#39;report2015.xls&#39;, &#39;report2015.doc&#39;) # пробуем извлечь xls-файлы c указанием якорей: files[grep(&#39;^report.*xls$&#39;, files)] [1] &quot;report2016.xls&quot; &quot;report2015.xls&quot; files[grep(&#39;^[^~$].*xls$&#39;, files)] [1] &quot;report2016.xls&quot; &quot;report2015.xls&quot; 3.1.9 Группы Квантификаторы обычно работают относительно предыдущего указанного символа. Однако нередко возникают ситуации, когда требуется провести какую-то операцию над определенной группой символов. В таких случаях используют знаки группировки - ( и ). Набор символов и/или выражение, заключенные в скобки, будут восприниматься как неразрывная последовательность символов, и обрабатываться соответствующим образом. Например, если мы хотим удалить из строки строго двукратное повторение группы символов: my_string &lt;- c(&#39;abRababL&#39;) # пробуем удалить пару символов без указания группы gsub(&#39;ab&#39;, &#39;_DELETED_&#39;, my_string) [1] &quot;_DELETED_R_DELETED__DELETED_L&quot; # группируем символы с помощью () gsub(&#39;(ab){2}&#39;, &#39;_DELETED_&#39;, my_string) [1] &quot;abR_DELETED_L&quot; При необходимости всю обрабатываемую строку можно, с помощью символьных классов, групп и прочих инструментов регулярных выражений, представить в паттерне. При подобном представлении группы нумеруются и может быть обработана конкретная группа символов, вызванная по номеру. Номера групп обозначаются как \\\\1-\\\\9. Например, в строке есть как текст, так и номер телефона, и мы хотим извлечь все, кроме текста и кода страны. Для этого мы пишем паттерн, который описывает всю строку, и необходимые нам части строки представляем в виде групп. Далее с помощью gsub() мы изменяем исходную строку так, что в ней остаются только требуемые нам группы из кодирующих телефонный номер: phone_number &lt;- &#39;my phone number: +7-929-138-58-96&#39; phone_number &lt;- &#39;my phone number: +7-929-1385896&#39; phone_pattern &lt;- &#39;.+(\\\\+[0-9]*)-?([0-9]{3})-?([0-9]{3})-?([0-9]{2})-?([0-9]{2})&#39; gsub(phone_pattern, &#39;\\\\2-\\\\3-\\\\4\\\\5&#39;, phone_number) [1] &quot;929-138-5896&quot; В примере выше конструкция .+ обозначает все возможные символы до группы (\\\\+[0-9]*), которая, в свою очередь, обозначает численный код страны. Код страны может сстоять как из одной цифры, так и из нескольких. Конструкция -? нужна для того, чтобы учесть ситуации, когда номер телефона записывается с разделителями, расставленными в произвольном порядке (+7-929-138-5896 vs +79291385896 vs +7-929-138-58-96 и т.д.). Группы ([0-9]{3}), ([0-9]{2}) обозначают, собственно, сколько раз должны повторяться цифры в этой группе символов. В результате в паттерне оказывается представлена вся строка, а элементы номера телефона представлены в виде пяти групп. Функция sub() находит в строке совпадение с паттерном и замещает строку на набор групп, \\\\2-\\\\3-\\\\4\\\\5, притом, четвертая и пятая группы сознательно не разделены знаком -, чтобы в результате последние четыре цифры номера были целостным блоком. Так как паттерн кодирует всю строку, то, в результате мы получаем только те части строки, которые описываются группами. В нашем случае это номер телефона без указания кода страны. "],["сбор-данных-из-интернета-rvest.html", "4 Сбор данных из интернета: rvest 4.1 Введение 4.2 Работа с пакетом rvest 4.3 Использование атрибута class", " 4 Сбор данных из интернета: rvest library(tidyverse) Достаточно часто данные не ходят упакованные в готовые файлы .csv или .json. Иногда данные лежат в открытом доступе на какой-нибудь странице в интернете (например, таблицы Левада-центра из предыдущего занятия). А иногда никто и не думал, что что-то станет данными: заголовки и тексты новостей, комментарии, твиты и т. п. В этом разделе мы обсудим основы извлечения данных из вебстраниц. 4.1 Введение Любая html-документ — это обычный xml файл. Обычно самый верхний узел называется html, который имеет два дочерних узла head и body. Каждый html-документ является инструкцией для браузера, в которой говориться что и в каком порядке нужно отображать, но одновременно эта инструкция является кодом, который мы можем посмотреть. В большинстве браузеров это можно сделать при помощи горячих клавиш Ctrl+U, в Apple Safari — Cmd+Option+U. Кроме того есть режим разработчика, который позволяет делать много всего, в том числе наводить на какой-то объект в браузере и узнавать какой фрагмент кода ему соответствует (этот режим можно вызвать, нажав F12 или Ctrl+Shift+I, в Apple Safari вроде нет горячих клавиш и нужно вызывать как-то из меню). Большинство узлов html-документа состоят из тег узла, например, p значения узла, например, Жили-были три медведя. id (уникальные объекты в html-документе), class (неуникальные объекты в html-документе) и другием атрибуты узла Например: &lt;p class=&quot;story&quot; some_atribute = 42&gt;Жили-были три медведя.&lt;/p&gt; Некоторые html-документ не являются статическими и изменяются после того, как страница была открыта при помощи JavaScript’а. Это динамичность может быть скрытой, когда пользователь лишь видит, как открывается страница, а иногда может быть завязана на некоторые действия пользователя. Информацию со статических страниц собирать достаточно просто и для этого нам хватит пакета rvest. C динамическими сайтами все иногда несколько сложнее. Иногда на диномических страницах можно отследить источник данных, посмотрев вкладку Network в режиме разработчика (ведь откуда-то эти данные появляются в браузере, правда?). Иногда необходимо делать POST и GET запросы, хранить cookies, и т. п. — все это можно сделать при помощи пакета httr, а в самых сложных случаях (когда JavaScript JavaScript погоняет) поможет пакет RSelenium. 4.2 Работа с пакетом rvest Пакет rvest позволяет скачивать страницы и потом их обрабатывать. Включим библиотеку: library(rvest) 4.2.1 Простой случай В качестве примера рассмотрим сайт Центра цифровых гуманитарных исследований НИУ ВШЭ: source &lt;- read_html(&quot;https://hum.hse.ru/digital&quot;) Объект source является списком, который содержит html-страницу. Давайте допустим, что мы хотем скачать все заголовки новостей, т. е. нам нужны значения всех узло h2. Функция html_nodes() позволяет вычленить исключительно узлы с каким-то тегом из всего xml-файла. source %&gt;% html_nodes(&quot;h2&quot;) Теперь если мы хотим обратиться к значениям этих узлов, мы можем использовать функцию html_text() source %&gt;% html_nodes(&quot;h2&quot;) %&gt;% html_text() Если мы откроем превью узла h2 (команда View()), то мы увидим что-то такое: Эта схема показывает, что каждый узел h2 содержит узел a который содержит три атрибута: title и href. Вложенность отображается знаком &gt;, а обращаться к атрибутам можно, используя функцию html_attr(): source %&gt;% html_nodes(&quot;h2 &gt; a&quot;) %&gt;% html_attr(&quot;title&quot;) -&gt; titles source %&gt;% html_nodes(&quot;h2 &gt; a&quot;) %&gt;% html_attr(&quot;href&quot;) -&gt; links tibble(titles, links) Как видно из получившейся таблицы, на первой странице сайта всего 10 новостей. А что если мы хотим скачать все новости? Исследовав страницу Центра цифровых гуманитарных исследований, становится понятно, что все новые страницы генерятся по одному и тому же паттерну: https://hum.hse.ru/digital/news/page2.html https://hum.hse.ru/digital/news/page3.html … https://hum.hse.ru/digital/news/page6.html и даже на первую страницу, на которую мы попали по короткому адресу &lt;hum.hse.ru/digital&gt;, можно также попасть по этому адресу https://hum.hse.ru/digital/news/page1.html Сгенерим список страниц: str_c(&quot;https://hum.hse.ru/digital/news/page&quot;, 1:6, &quot;.html&quot;) А теперь сделаем функцию, которая ходит по страницам и все собирает map_dfr(str_c(&quot;https://hum.hse.ru/digital/news/page&quot;, 1:6, &quot;.html&quot;), function(x){ source &lt;- read_html(x) source %&gt;% html_nodes(&quot;h2 &gt; a&quot;) %&gt;% html_attr(&quot;title&quot;) -&gt; titles source %&gt;% html_nodes(&quot;h2 &gt; a&quot;) %&gt;% html_attr(&quot;href&quot;) -&gt; links tibble(titles, links) }) -&gt; df_news df_news Создайте датафрейм, содержащий заголовки и ссылки на новости со страницы Магистерской программы «Цифровые методы в гуманитарных науках». 4.3 Использование атрибута class Допустим, нас интересует дата создания новости на странице Центра цифровых гуманитарных исследований. Исследовав сайт, легко обнаружить, что информация о дате создания новости хранится в теге span. Однако, если мы попробуем использовать лишь эту информацию, то мы получим много лишнего: source %&gt;% html_nodes(&quot;span&quot;) %&gt;% html_text() %&gt;% head(20) Дело в том, что тег span имеется у многих других объектов на странице. Однако, если присмотреться к значениям, которые мы находим в режиме разработчика, можно заметить следующее: Если посмотреть код, то мы увидем следующее: ... &lt;span class=&quot;post__date&quot;&gt; 17 декабря, 2019 г.&lt;/span&gt; ... Чтобы обратиться к таким элементам нужно использовать точку: source %&gt;% html_nodes(&quot;span.post__date&quot;) %&gt;% html_text() Почистим: source %&gt;% html_nodes(&quot;span.post__date&quot;) %&gt;% html_text() %&gt;% str_remove_all(&quot;\\\\n|\\\\t&quot;) Постройте график, показывающий количество новостей Центра цифровых гуманитарных исследований за каждый месяц. 4.3.1 Чтение таблиц Таблицы, которые хранятся на html-странице можно считывать как таблицы (а, не например, построчно). Рассмотрим вкладку “Число студентов и вакантные места” на сайте Магистерской программы «Цифровые методы в гуманитарных науках»: source &lt;- read_html(&quot;https://www.hse.ru/ma/dh/vacant&quot;) source %&gt;% html_node(&quot;table&quot;) %&gt;% html_table() Функция html_node() возвращает первую таблицу на странице. В предыдущих разделах мы использовали функцию html_nodes(), которая вытаскивает все узлы с соответствующими атрибутами: source %&gt;% html_nodes(&quot;table&quot;) %&gt;% html_table() -&gt; l str(l) Получился список (объект типа list), в котором содержаться все таблицы со страницы. Так что, для того, чтобы работать с конкретной таблицей нужно использовать индексацию списков: l[[1]] 4.3.2 Некоторые советы Некоторые ресурсы блокируют возможность скачивать из них данные. Обычно это делается на уровне сервера, который видит, что с какого-то IP приходит по 5 запросов в секунду и ограничивает доступ, на случай если вы начинаете DDoS атаку. Если сервер не отдает вам данные или отдает, но раз в какой-то временной промежуток, следует прописать в вашей программе ожидание (команда Sys.sleep()). Некоторые сайты, например, Википедия, специально архивирует данные, чтобы люди не пытались ее обкачать: вот страница, на которой это подробно описано. "],["работа-с-текстами-gutenbergr-tidytext-stopwords-udpipe.html", "5 Работа с текстами: gutenbergr, tidytext, stopwords, udpipe 5.1 Загрузка текста в R 5.2 gutenbergr 5.3 tidytext и stopwords 5.4 Визуализация биграмм с igraph и ggraph 5.5 Пакет stopwords 5.6 Пакет udpipe 5.7 Задания", " 5 Работа с текстами: gutenbergr, tidytext, stopwords, udpipe Привет, дорогие пацаны и пацанессы! День второй, вы, предположительно, поразвлекались с регулярками, жизнь продолжается, давайте же анализировать тексты! В этом эпизоде сериала АйсДан мы выясним, как обычно выглядят текстовые данные (и откуда их, кстати, брать!), как мы хотим, чтобы текстовые данные выглядели, и как перевести одно в другое. Бонус: смешные графики! МЕСТО ДЛЯ ВИДЕО :)) В видео: 1) форматы текстовых данных (массив текста -&gt; term-document matrix) 2) Токены и токенизация 3) Стемминг и лемматизация Для начала давайте установим нужные библиотеки: 5.1 Загрузка текста в R В пакете readr, который входит в tidyverse, есть функция read_lines(). Такая же по сути функция есть в base R, она называется readLines(), но она работает гораздо медленнее, так что мы ей пользоваться не будем. read_lines() принимает на вход путь к файлу с текстом на вашем компьютере или ссылку на файл в Интернете. Например, у Гарика на гитхабе есть документ с текстом книги Теда Чана “История твоей жизни” (судя по Википедии, это научно-фантастическая повесть о лингвистке, изучающей язык пришельцев. Звучит прикольно). Давайте считаем этот файл. t &lt;- read_lines(&quot;https://raw.githubusercontent.com/agricolamz/2020_HSE_DPO/master/data/Chang.txt&quot;) head(t) read_lines() создал вектор строк: class(t) В каждом элементе вектора у нас содержится одна строчка (в смысле, line) из книги. Чтобы превратить текст в единое целое, воспользуемся уже известной нам функцией str_c() из библиотеки stringr, и склеим, используя пробел как разделитель. t2 &lt;- stringr::str_c(t, collapse = &quot; &quot;) length(t2) str_length(t2) При таком слиянии стоит проверить, не было ли в анализируемом тексте знаков переноса, иначе они сольются неправильно: str_c(c(&quot;... она запо-&quot;, &quot;лучила ...&quot;), collapse = &quot; &quot;) 5.2 gutenbergr Библиотека gutenbergr это API для проекта Gutenberg - онлайн-библиотеки электронных книг, которую создал Майкл Харт, изобретатель, собственно, формата электронных книг. Там хранится куча документов, которые по каким-то причинам не защищены авторским правом, так что мы можем совершенно легально их скачивать и анализировать (ну, или читать). В этой библиотеке нас интересуют две вещи: объект gutenberg_metadata, в котором хранится информация о всех книгах, которые есть в библиотеке, и функция gutenberg_download(), которая позволяет их скачивать. Начнём с первого. str(gutenberg_metadata) У каждого документа указан автор (если он есть) и название, author и title. Например, мы можем узнать, книг какого автора в библиотеке больше всего: gutenberg_metadata %&gt;% count(author, sort = TRUE) Сколько произведений Джейн Остин (не перепутайте с другими Остин) есть в датасете? gutenberg_metadata %&gt;% filter(author == &quot;Austen, Jane&quot;) %&gt;% distinct(gutenberg_id, title) Ещё у каждой книги есть свой уникальный ID, который хранится в колонке gutenberg_id. По этому ID книгу можно скачать, используя функцию gutenberg_download(). Давайте скачаем “Эмму”: emma &lt;- gutenberg_download(158, mirror = &quot;http://mirrors.xmission.com/gutenberg/&quot;) emma Можно скачивать сразу несколько книг. Давайте добавим еще “Леди Сьюзен”: books &lt;- gutenberg_download(c(158, 946), meta_fields = &quot;title&quot;, mirror = &quot;http://mirrors.xmission.com/gutenberg/&quot;) books books %&gt;% count(title) Сколько уникальных заголовков из базы данных содержит “Sherlock Holmes?” 5.3 tidytext и stopwords Сейчас наши книги хранятся в тиббле, в котором есть три колонки: class(books) colnames(books) Причём для каждой из книг у нас куча строк: books %&gt;% count(title) Это потому что одна строка в тиббле это одна строка книги. Мы можем снова воспользоваться функцией str_c() и слить весь текст в одну гигантскую строку, но вместо этого мы токенизируем наши тексты, используя в качестве токенов (=смысловых единиц) слова. Если вы посмотрели видео в начале, то уже знаете, что такое токенизация, а если не посмотрели, то идите и посмотрите :) Для токенизации мы будем использовать функцию unnest_tokens() из библиотеки tidytext (про эту библиотеку есть книга, которую можно прочитать здесь). В аргумент output функции unnest_tokens() подается вектор с именем будущей переменной, а аргумент input принимает имя переменной, в которой в нашем тиббле хранится текст. По умолчанию unnest_tokens() делит текст на слова, хотя есть и другие опции, которые можно указать в аргументе token. Но пока давайте поисследуем слова. library(tidytext) books %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) Теперь можно посчитать самые частотные слова в обоих произведениях: books %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) %&gt;% count(title, word, sort = TRUE) Ну… Это было ожидаемо. Нужно убрать стоп-слова. Английские стоп-слова встроены в пакет tidytext (переменная stop_words): books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% anti_join(stop_words) Постройте следующий график, на котором представлены самые частотные 20 слов каждого из произведений. Как видно, на графике всё не упорядочено, давайте начнем с такого примера: books %&gt;% unnest_tokens(word, text) %&gt;% count(word, sort = TRUE) %&gt;% slice(1:20) %&gt;% ggplot(aes(n, word))+ geom_col() Если мы работаем с одним фасетом, то все проблемы может решить функция fct_reorder(), которая упорядочивает на основании некоторой переменной: books %&gt;% unnest_tokens(word, text) %&gt;% count(word, sort = TRUE) %&gt;% slice(1:20) %&gt;% mutate(word = fct_reorder(word, n)) %&gt;% ggplot(aes(n, word))+ geom_col() Однако, если мы применим это к нашим данным, то получится неупорядочено, потому что fct_reorder()упорядочивает, не учитывая, где какой текст: books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% group_by(title) %&gt;% slice(1:20) %&gt;% ungroup() %&gt;% mutate(word = fct_reorder(word, n)) %&gt;% ggplot(aes(n, word))+ geom_col()+ facet_wrap(~title, scales = &quot;free&quot;) В пакете tidytext есть функция reorder_within(), которая позволяет упорядочить нужным образом: books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% group_by(title) %&gt;% slice(1:20) %&gt;% ungroup() %&gt;% mutate(word = reorder_within(x = word, by = n, within = title)) %&gt;% ggplot(aes(n, word))+ geom_col()+ facet_wrap(~title, scales = &quot;free&quot;) Чтобы избавиться от дополнительной подписи, нужно использовать scale_y_reordered() или scale_x_reordered(): books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% group_by(title) %&gt;% slice(1:20) %&gt;% ungroup() %&gt;% mutate(word = reorder_within(x = word, by = n, within = title)) %&gt;% ggplot(aes(n, word))+ geom_col()+ facet_wrap(~title, scales = &quot;free&quot;)+ scale_y_reordered() Ещё один способ графически представить самые частотные слова это сделать облако слов. Есть библиотека wordclouds с функцией wordcloud. Давайте построим облако слов для романа Lady Susan. Для раскрашивания слов в разные цвета я использую палитру из великой библиотеки wesanderson с цветами разных фильмов, собственно, Уэса Андерсона. pal &lt;- wes_palette(&quot;Royal2&quot;) books %&gt;% filter(title == &#39;Lady Susan&#39;) %&gt;% unnest_tokens(input = &#39;text&#39;, output = &#39;word&#39;) %&gt;% count(title, word, sort = TRUE) %&gt;% anti_join(stop_words) %&gt;% with(wordcloud(word, n, random.order = FALSE, max.words = 50, colors=pal)) wordcloud, к сожалению, не совместим с ggplot2 без которого, например, гораздо сложнее сделать фасетизацию и не задолбаться. Зато есть библиотека ggwordcloud, в которой есть geom_text_wordcloud. Воспользуемся же им! Предварительное предупреждение: если слов в облако надо вместить много, то `ggwordcloud указывает для редко встречающихся очень маленький размер шрифта. ggplot от этого волнуется и выдаёт ворнинги, по одному на каждое слово. Это я к чему: график в чанке снизу выдаёт миллион ворнингов. В этом мануале они спрятаны, а когда столкнётесь с ними при выполнении заданий, можете их игнорировать. И, конечно, совершенно не обязательно включать слова, которые встречаются всего пару раз в очень длинном тексте. books %&gt;% unnest_tokens(input = &#39;text&#39;, output = &#39;word&#39;) %&gt;% count(title, word, sort = TRUE) %&gt;% anti_join(stop_words) %&gt;% filter(n &gt; 20) %&gt;% ggplot(aes(label = word, size = n, color = n)) + geom_text_wordcloud(rm_outside = TRUE) + facet_wrap(~title, scale = &#39;free&#39;) + scale_size_area(max_size = 10) Поиск самых частотных слов — не единственная задача, которую можно решать при работе с текстом. Иногда имеет смысл узнать распределение слов в произведении. Давайте посмотрим как распределены в романе “Эмма” фамилии главных героев: books %&gt;% filter(title == &quot;Emma&quot;) %&gt;% unnest_tokens(word, text) %&gt;% mutate(narrative_time = 1:n()) %&gt;% filter(str_detect(word, &quot;knightley$|woodhouse$|churchill$|fairfax$&quot;)) %&gt;% ggplot()+ geom_vline(aes(xintercept = narrative_time))+ facet_wrap(~word, ncol = 1) Функция unnest_tokens() позволяет работать не только со словами, но и, напрмиер, с n-граммами, то есть сочетаниями из n слов. Важно понимать, что n-граммы образуются “внахлёст”: txt &lt;- tibble(text = &quot;I&#39;m a Barbie girl in a Barbie world&quot;) txt %&gt;% unnest_tokens(bigram, text, token = &quot;ngrams&quot;, n = 2) Чтобы преобразовать текст в биграммы, надо уточнить, что token = \"ngrams\", а n=2. books %&gt;% unnest_tokens(bigram, text, token = &quot;ngrams&quot;, n = 2) Если мы посмотрим на самые частотные биграммы, то увидим кучу несодержательных вещей. books %&gt;% unnest_tokens(bigram, text, token = &quot;ngrams&quot;, n = 2) %&gt;% count(bigram, sort = TRUE) Почему? Снова стоп-слова-злодеи! Чтобы их убрать, надо разделить биграммы, отфильтровать так, чтобы остались только биграммы без стоп-слов, и снова склеить. Для этого мы воспользуемся функциями separate и unite, вот так (и заодно избавимся от NA’ев): books %&gt;% unnest_tokens(bigram, text, token = &quot;ngrams&quot;, n = 2) %&gt;% drop_na()%&gt;% separate(bigram, c(&#39;word1&#39;, &#39;word2&#39;), sep = &#39; &#39;) %&gt;% filter(!(word1 %in% stop_words$word) &amp; !(word2 %in% stop_words$word)) %&gt;% count(word1, word2, sort = TRUE) %&gt;% unite(bigram, word1, word2, sep = &quot; &quot;) 5.4 Визуализация биграмм с igraph и ggraph Биграммы можно представить теми же способами, что и слова, а можно визуализировать сеть связей между словами в таком как бы графе. Для этого мы будем пользоваться двумя библиотеками: igraph и ggraph. Из igraph нам понадобится функция graph_from_data_frame(), которой мы скормим тиббл с данными о частотности биграмм, а ggraph будем использовать, чтобы построить график. Для графика нам нужно три переменных: - from, от какого “узла” (слова) начинается связь - to, в какой узел (слово) связь идёт - weight, вес этой связи. В нашем случае - насколько часто эта связь (то есть, конкретная биграмма) встречается в тексте. graph_from_data_frame() берёт тиббл (или любой дата фрейм) с этой информацией и преобразует его в объект, из которого можно делать граф. Давайте совершим все эти преобразования и заодно оставим только биграммы, которых больше 20: bigrams_graph &lt;- books %&gt;% unnest_tokens(bigram, text, token = &quot;ngrams&quot;, n = 2) %&gt;% drop_na() %&gt;% separate(bigram, c(&quot;word1&quot;, &quot;word2&quot;), sep = &quot; &quot;) %&gt;% filter(!(word1 %in% stop_words$word) &amp; !(word2 %in% stop_words$word)) %&gt;% count(word1, word2, sort = TRUE) %&gt;% filter(n &gt; 20) %&gt;% graph_from_data_frame() bigrams_graph А теперь можно и график делать: ggraph(bigrams_graph, layout = &quot;fr&quot;) + geom_edge_link() + geom_node_point() + geom_node_text(aes(label = name), vjust = 1, hjust = 1) 5.5 Пакет stopwords Выше мы упомянули, что в пакет tidytext встроен список английских стоп-слов. Стоп-слова для других язков можно раздобыть, используя пакет stopwords. Вместо имени языка, функция принимает ISO-код языка: library(stopwords) stopwords(&quot;ru&quot;) Пакет предоставляет несколько источников списков: stopwords_getsources() Давайте посмотрим, какие языки сейчас доступны: map(stopwords_getsources(), stopwords_getlanguages) Мы видим, что есть несколько источников для русского языка: length(stopwords(&quot;ru&quot;, source = &quot;snowball&quot;)) length(stopwords(&quot;ru&quot;, source = &quot;stopwords-iso&quot;)) В зависимости от того, насколько консервативными вы хотите быть в плане стоп-слов (например, “сказал” это стоп-слово или нет?), можете выбирать тот или другой список. Ну и всегда можно попробовать оба и выбрать тот, который даёт более осмысленный результат. 5.6 Пакет udpipe Пакет udpipe представляет лемматизацию, морфологический и синтаксический анализ разных языков. Туториал можно найти здесь, там же есть список доступных языков. library(udpipe) Модели качаются очень долго. enmodel &lt;- udpipe_download_model(language = &quot;english&quot;) Теперь можно распарсить какое-нибудь предложение: udpipe(&quot;The want of Miss Taylor would be felt every hour of every day.&quot;, object = enmodel) Скачаем русскую модель: rumodel &lt;- udpipe_download_model(language = &quot;russian-syntagrus&quot;) udpipe(&quot;Жила-была на свете крыса в морском порту Вальпараисо, на складе мяса и маиса, какао и вина.&quot;, object = rumodel) После того, как модель скачана, можно уже к ней обращаться просто по имени файла: udpipe(&quot;Жила-была на свете крыса в морском порту Вальпараисо, на складе мяса и маиса, какао и вина.&quot;, object = rumodel) udpipe лемматизирует наш текст (то есть, теперь “мясо” и “мяса” распрознаются как одно и то же слово), а также помечает, к какой части речи это слово относится, по универсальной классификации. С таким текстом, например, можно посмотреть на то, как часто встречаются только определённые части речи. И последний комментарий про udpipe: лемматизациz дело не быстрое, поэтому, скорее всего, лемматизировать все фанфики скопом у вас не получится. Вместо этого предлагается сделать сэмпл (то есть, рандомно выбрать, например, 300 фанфиков) и работать с ними. Если 300 вашему компьютеру тяжело - можно меньше. Соответственно, в заданиях, где нужна лемматизация, сэмплируйте датасет и работайте с сэмплом. А теперь - собственно, задания! 5.7 Задания Найдите три самыx популярных (по количеству лайков) фанфика и постройте барплоты для самых часто встречающихся слов в этих фанфиках. Найдите самый длинный фанфик (не забывайте, что в нашем датасете одна строка это одна глава, а глав бывает несколько) и постройте для него граф биграмм (не всех, конечно, а тех, что встречаются чаще скольки-то раз). Для того же самого длинного фанфика по самым частотным словам поймите, какие в нём есть персонажи и как их зовут. Постройте график, который показывает, как частота появления разных персонажей меняется на протяжении фанфика. Какие прилагательные чаще всего используются в вашем фандоме со словом “глаз” (в любой форме)? Проиллюстрируйте облаком слов. Именно здесь вам понадобится лемматизация, так что используйте сэмпл. Найдите самого плодовитого автора в вашем фандоме (то есть, такого, который написал больше всего фанфиков). Попробуйте найти клише, которые встречаются в его или её текстах. Тут можно посмотреть на биграммы, триграммы или и то, и другое - посмотрите, что интереснее, и покажите на графике (можно барплот, можно сделать облако слов, можете придумать свой вариант). Если у вас появятся вопросы - смело задавайте их в канале #text-preprocessing-questions, а все странные и нелепые графики присылайте в #accidental-art. Удачи! "],["анализ-текста.html", "6 Анализ текста 6.1 Данные 6.2 tf-idf 6.3 Предиктивный ввод текста 6.4 Анализ тональности 6.5 Тематическое моделирование", " 6 Анализ текста 6.1 Данные Для работы мы воспользуемся двумя датасетами: Рассказы М. Зощенко zo &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020_HSE_DPO/master/data/zoshenko.csv&quot;) zo Курс начертательной геометрии под редакцией В.Гордона geom &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020_HSE_DPO/master/data/gordon_geometry.csv&quot;) Для начала лемматизируем полуичвшиеся тексты: library(udpipe) rus &lt;- udpipe_load_model(&quot;russian-syntagrus-ud-2.4-190531.udpipe&quot;) geom_tokenized &lt;- udpipe(geom, object = rus) zo_tokenized &lt;- udpipe(zo, object = rus) Уберем стопслова и леммы, содержащие цифры и знаки препинания library(stopwords) sw &lt;- tibble(lemma = stopwords(language = &quot;ru&quot;)) geom_tokenized %&gt;% bind_rows(zo_tokenized) %&gt;% filter(!str_detect(lemma, &quot;\\\\W|\\\\d&quot;)) %&gt;% anti_join(sw) %&gt;% select(doc_id, sentence_id, lemma) -&gt; all_texts all_texts Используйте библиотеку gutenbergr и скачайте “Чувство и чувствительность”(Sense and Sensibility, gutenberg_id = 161) и “Гордость и предубеждение” (“Pride and Prejudice,” gutenberg_id = 1342). Приведите тексты к tidy формату и уберите стопслова (английские стопслова есть в переменной stop_words пакета tidytext). Приведите, сколько получилось слов в романе “Чувство и чувствительность” после удаления стопслов: Приведите, сколько получилось слов в романе “Гордость и предубеждение” после удаления стопслов: 6.2 tf-idf tf-idf — важная мера, которая позволяет выделять важные для текста слова. \\[tf = \\frac{количество\\ употреблений\\ единицы\\ в\\ тексте}{количество\\ уникальных\\ единиц\\ в тексте}\\] \\[idf = log\\left(\\frac{количество\\ документов\\ в\\ корпусе}{количество\\ документов\\ с\\ исследуемой\\ единицей}\\right)\\] \\[TfIdf = tf \\times idf\\] library(tidytext) all_texts %&gt;% count(doc_id, lemma) %&gt;% bind_tf_idf(lemma, doc_id, n) %&gt;% arrange(tf_idf) %&gt;% group_by(doc_id) %&gt;% top_n(5) %&gt;% ungroup() %&gt;% mutate(lemma = reorder_within(lemma, tf_idf, doc_id)) %&gt;% ggplot(aes(tf_idf, lemma))+ geom_col()+ facet_wrap(~doc_id, scales = &quot;free&quot;)+ scale_y_reordered() Давайте попробуем посчитать всего Зощенко одним корпусом: all_texts %&gt;% mutate(doc_id = ifelse(doc_id != &quot;gordon_geometry&quot;, &quot;zoshenko&quot;, &quot;gordon_geometry&quot;)) %&gt;% count(doc_id, lemma) %&gt;% bind_tf_idf(lemma, doc_id, n) %&gt;% arrange(tf_idf) %&gt;% group_by(doc_id) %&gt;% top_n(20) %&gt;% ungroup() %&gt;% mutate(lemma = reorder_within(lemma, tf_idf, doc_id)) %&gt;% ggplot(aes(tf_idf, lemma))+ geom_col()+ facet_wrap(~doc_id, scales = &quot;free&quot;)+ scale_y_reordered() Используя созданную ранее переменную с текстами Джейн Остин без стопслов, выделите по 20 слов, важных для каждого романа. 6.3 Предиктивный ввод текста На прошлом занятии мы разобрались, что пакет tidytext позволяет делить не только на отдльные слова, но и смотреть на биграммы. Частотность биграмм можно использовать в подсказке слова, которую мы видим в наших телефонах: zo %&gt;% unnest_tokens(&quot;bigram&quot;, text, token = &quot;ngrams&quot;, n = 2) %&gt;% separate(bigram, into = c(&quot;word_1&quot;, &quot;word_2&quot;)) %&gt;% count(word_1, word_2, sort = TRUE) -&gt; bigrams Теперь у нас есть биграмы: bigrams %&gt;% filter(word_1 == &quot;однажды&quot;) bigrams %&gt;% filter(word_1 == &quot;днем&quot;) bigrams %&gt;% filter(word_1 == &quot;присела&quot;) bigrams %&gt;% filter(word_1 == &quot;ждет&quot;) bigrams %&gt;% filter(word_1 == &quot;а&quot;) %&gt;% head() bigrams %&gt;% filter(word_1 == &quot;я&quot;) %&gt;% head() bigrams %&gt;% filter(word_1 == &quot;говорю&quot;) %&gt;% head() bigrams %&gt;% filter(word_1 == &quot;не&quot;) %&gt;% head() bigrams %&gt;% filter(word_1 == &quot;могу&quot;) %&gt;% head() Вот мы и получили предложение “Однажды днем присела ждет, а я говорю: ‘не могу’.” На большом корпусе результаты будут лучше, но легко предсатвить, как сделать из этого рабочую функцию. Можно переиначить задачу и работать с символами, тогда это будет ближе к T9 на современных телефонах. Используя тексты обоих романов создайте генератор текстов, основанный на биграммах. Какое трехсловное предложение получится, если выбирать самое частотную пару, и начать со слова I? 6.4 Анализ тональности Linis Crowd лемма значение среднеквадратичное отклонение РуСентиЛекс: слово или словосочетание, часть речи или синтаксический тип группы, слово или словосочетание в лемматизированной форме, тональность: позитивная (positive), негативная(negative), нейтральная (neutral) или неопределеная оценка, зависит от контекста (positive/negative), источник: оценка (opinion), чувство (feeling), факт (fact), если тональность отличается для разных значений многозначного слова, то перечисляются все значения слова по тезаурусу РуТез и дается отсылка на сооветствующее понятие - имя понятия в кавычках. Мы будем использовать датасет, составленный на базе Linis Crowd ru_sentiments &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020_HSE_DPO/master/data/ru_sentiment_linis-crowd.csv&quot;) all_texts %&gt;% group_by(doc_id) %&gt;% left_join(ru_sentiments, by = c(&quot;lemma&quot; = &quot;words&quot;)) %&gt;% mutate(value = ifelse(is.na(value), 0, value)) %&gt;% group_by(doc_id, sentence_id) %&gt;% summarise(value = sum(value)) %&gt;% mutate(color = ifelse(value &gt;= 0, &quot;positive&quot;, &quot;negative&quot;)) %&gt;% ggplot(aes(sentence_id, value, fill = color))+ geom_col()+ facet_wrap(~doc_id, scales = &quot;free&quot;) 6.5 Тематическое моделирование LDA (Latent Dirichlet allocation) — один из базовых способов, используемый в тематическом моделировании. Основное идея алгаритма, заключается в том, что каждый текст может являтся смесью тем, а каждая тема имеет вероятность более высокую вероятность генерировать некоторые слова, и более низкую вероятность генерировать слова общие для всех тем. На вход подается посчитанный список слов для каждого текста. library(topicmodels) all_texts %&gt;% count(doc_id, lemma) %&gt;% cast_dtm(doc_id, lemma, n) %&gt;% # особая функция LDA(k = 2, # количество тем control = list(seed = 42) # повзоляет воспроизвести один и тот же анализ, можно убрать ) -&gt; lda Посмотрим, какие слова характерны для какой темы (т. е. самые частотные в теме): lda %&gt;% tidy(matrix = &quot;beta&quot;) %&gt;% # приводим модель в tidy формат group_by(topic) %&gt;% top_n(15, beta) %&gt;% ungroup() %&gt;% mutate(term = reorder_within(term, beta, topic)) %&gt;% ggplot(aes(term, beta, fill = factor(topic))) + geom_col(show.legend = FALSE) + facet_wrap(~topic, scales = &quot;free&quot;) + coord_flip() + scale_x_reordered() Посмотрим, какие слова специфичны для каждой из тем (т. е. частота значительно больше в одной теме, чем в другой): lda %&gt;% tidy(matrix = &quot;beta&quot;) %&gt;% mutate(topic = paste0(&quot;topic&quot;, topic)) %&gt;% spread(topic, beta) %&gt;% filter(topic1 &gt; .006 | topic2 &gt; .002) %&gt;% # эти значения нужно вручную подбирать mutate(log_ratio = log2(topic2 / topic1), term = fct_reorder(term, log_ratio)) %&gt;% ggplot(aes(log_ratio, term))+ geom_col() Посмотрим на распределение текстов по темам: lda %&gt;% tidy(matrix = &quot;gamma&quot;) "],["ссылки-на-литературу.html", "Ссылки на литературу", " Ссылки на литературу "]]
