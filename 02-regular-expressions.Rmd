---
editor_options: 
  chunk_output_type: console
---

```{r setup02, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, comment = "")
options(scipen=999)
library(tidyverse)
theme_set(theme_bw())
```

# Регулярные выражения {#strings2}
## Регулярные выражения {#strings-regexp}
### Паттерны {#strings-patterns}
В примерах к функциям `gsub()` и  `regexpr()` мы упоминали и применяли особые конструкции, которые используются при обработке строковых данных - регулярные выражения. Регулярные выражения (англ. Regular Expressions, regexps)- это специальный язык для описания шаблонов строк, который используется для поиска определенных строк, проверки их на соответствие какому-либо шаблону и другой подобной работы. В функци `gsub()` и  `regexpr()` мы как раз искали необходимые нам части строк с помощью паттернов (шаблонов), написанных в виде регулярнх выражений.

Реализация регэкспов в разных языках программирования может различаться, в R используется расширенная версия регулярных выражений (ERE, стандарт POSIX 1003.2) с некоторыми собственными дополнениями, а так же Perl-совместимые регулярные выражения (PCRE 8.36). Согласно стандарту POSIX 1003.2, длина регулярных выражений не может превышать 256 байтов. Впрочем, как показывает практика, с таким ограничением мало кто сталкивается в своей работе.

С регулярными выражениями есть, к сожалению, одна достаточно неприятная особенность - если выражение написано неправильно (в частности, при использовании  метасимволов), то в результате, в зависимости от контекста использования, будет либо пропуск нужных элементов, либо просто отсутствие какого-либо эффекта. Поэтому есть смысл упрощать работу с регулярными выражениями, особенно если нет достаточного опыта их использования. Например, разбивать делать изменение части строки в несколько этапов, или же просто тестировать регулярные выражения небольшими блоками.

### Символы {#strings-symbols}
В большинстве своем символы в регулярных выражениях обозначают сами себя, за некоторыми исключениями. Каждый символ в паттерне задает соответствие только одному символу в строке, поэтому в тех случаях, когда необходимо указать какой-то символ из определенного набора или указать, что какой-то символ повторяется некоторое количество раз подряд, следует использовать символьные классы или квантификаторы соответственно.

В R ряд функций для поиска и замены строк по паттерну имеют две версии - первая обрабатывает только первоей найденное значение, соответствующее паттерну, вторая версия - все найденные по паттерну значения. Например, функция `sub()` находит и заменяет первое вхождение искомого символа, `gsub` - все вхождения:
```{r 08-handling-with-strings-14 }
# задаем строку
my_string <- 'mystring998989'

# удаляем символ 9, первое вхождение
sub('9', "", my_string)

# удаляем все символы `9` с помощью функции gsub() 
gsub('9', "", my_string)
```

Если в паттерне указать несколько символов, то поиск по строке будет произведен именно по такому сочетанию символов. Например, удалим из строки (заменим на пустую строку) сочетание `89`:
```{r 08-handling-with-strings-15 }
# удаляем сочетание символов 89, первое вхождение
sub('89', "", my_string)

# удаляем сочетание символов 89, все вхождения
gsub('89', "", my_string)
```

Следует учитывать, что некоторые символы или сочетания символов могут быть проинтерпретированы либо как управляющие конструкции регулярных выражений (см. #text_metacharacters) и тогда потребуются дополнительные указания, как должны быть обработаны эти символы. Во-вторых, некоторые группы символов могут просто иметь дополнительные фиксированные значения. Так, для кодирования перехода на новую строку, табуляции и некоторых других непечатаемых символов используются определенные обозначения: `\n`, `\r`, `\t`, `\v`, `\f`. Соответственно, если в строке встретится какое-то из этих сочетаний, то строка будет прочитана и обработана не как строка, содержащая символы обратного слеша и буквы, а как строка с спец.символом (в случае с табуляцией - `\t`):
```{r 08-handling-with-strings-16 }
string_with_tab <- 'metachara\tcters'
cat(string_with_tab)

# пробуем удалить из строку букву t
gsub('t', '_DELETED_', string_with_tab)
```
Подобные символы, тем не менее, можно обрабатывать как и все прочие:
```{r 08-handling-with-strings-17 }
gsub('\t', '_DELETED_', string_with_tab)
```

### Классы символов {#strings-classes}
Задачи на поиск конкретного символа с помощью регулярных выражений встречаются, но, в целом, стоит признать, что обычно требуется большая гибкость поиска. Например, не конкретный символ или сочетание символов, а какой-либо символ из набора - знаки пунктуации или же цифры.

Cамостоятельно указать какой-то набор символов с помощью квадратных скобок (стоит помнить, что квадратные скобки как метасимволы регулярных выражений и квадратные скобки в R - это разные конструкции). При этом можно либо просто перечислить все символы набора, либо, если они принадлежат какому-то известному множеству (например, цифры), то указать первый и последний элементы множества через знак дефиса (`-`). Также можно сочетать сокращенные формы записи наборов символов. Символы кириллического и латинского алфавитов - разные множества, точно также как строчные и прописные буквы.

Внутри классов поведение метасимволов может различаться в зависимости от места их указания в наборе символов класса. Например, `^` первым символов в наборе символов задает логическое отрицание `не из этих символов`, и чтобы избежать такого поведения, знак `^` надо поставить на любое место кроме первого в цепочке. Знак `]`, если есть необходимость его вкючения в набор символов, наоборот, надо ставить первым в наборе, в противном случае он будет проинтерпретирован как завершение класса. Знак `-`, если указан не первым и не последним, интерпретируется как знак интервала в известном диапазоне символов (например, `[0-9]` означает от `0` до `9`, а `[09-]` - символы `0`, `9` и `-`)

```{r 08-handling-with-strings-18 }
# задаем строку
my_string <- 'D9586bNd879мрЯпп'

# укажем, что удалить надо любую из цифр
gsub('[0123456789]', '', my_string)
gsub('[0-9]', '', my_string)

# удаляем цифры, а так же строчные буквы кириллицы и латиницы
gsub('[0-9a-zа-я]', '', my_string)
```

#### Символьные классы в POSIX {#strings-classes-posix}
Стандарт POSIX 1003.2 поддерживает несколько определенных обозначения для часто используемых символьных классов:

- `[:alnum:]`: все буквы и цифры, сочетание символьных классов `[:alpha:]` и `[:digit:]`.

- `[:alpha:]`: буквы алфавита в обоих регистрах, для прописных и строчных букв есть отдельные символьные классы: `[:lower:]` и `[:upper:]`.

- `[:punct:]`: знаки пунктуации, ```!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~.```.


- `[:digit:]`: арабские цифры `0123456789`.

- `[:xdigit:]`: цифры в шестнадцатеричном формате, `0123456789ABCDEFabcdef`.

- `[:graph:]`: графические знаки, объединенный класс, состоящий из классов `[:alnum:]` и  `[:punct:]`.

- `[:print:]`: печатаемые знаки, класс `[:graph:]`, дополненный пробелом.

- `[:blank:]`: непечатаемые символы (пробел, знак табуляции, в зависимости от локали - неразрывный пробел и возможные другие непечатаемые символы).

- `[:cntrl:]`: управляющие символы (в таблицах символов ANSCII коды 000-031 и 121 в десятичной, 000-037 и 177 в восьмеричной системе, 000-07F в шестнадцатеричной системах счислений)

- `[:space:]`: некоторые управляющие символы, которые используются для создания разрывов между символами - пробел, переход на новую строку, возврат каретки, перевод страницы и т.д. В зависимости от локали может содержать дополнительные знаки.


При указании символьного класса с помощью его имени надо помнить, что обозначение класса также заключается в `[]`. То есть, вместо `[:digit:]` (обозначение класса) надо использовать `[[:digit:]]` (указание символьного класса в рег.выражении):
```{r 08-handling-with-strings-19 }
gsub('[[:digit:]]', '', my_string)
```

#### Дополнительные символьные классы {#strings-classes-extra}
Помимо обозначений символьных классов, которые поддерживаются стандартом POSIX, также в R реализован ряд собственных символьных классов, которые, как правило, обозначают наиболее часто используемые комбинации:

- `\\d`: цифры, аналогично `[0-9]`

- `\\D`: не цифры, обратно `\\d`, аналогично `[^0-9]`

- `\\w`: символы, которые используются в письме, аналогично `[A-z0-9_]`

- `\\W`: обратный `\\w` набор, символы, которые не используются в письме

- `\\S`: все знаки, кроме пробела. Аналогично `[^[:space:]]` или `[^\\s]`

```{r 08-handling-with-strings-20 }
# задаем строку
my_string <- 'D9586bNd879мрЯпп'

# удаляем все цифры с помощью класса [0-9]
gsub('[0-9]', '', my_string)

# удаляем все цифры с помощью класса [:digit:]
gsub('[[:digit:]]', '', my_string)

# удаляем все цифры с помощью класса \\d
gsub('\\d', '', my_string)
```

### Метасимволы {#strings-metacharacters}
Ряд символов имеет дополнительное значение - эти символы используются не только сами по себе, но и как определенные конструкции языка регулярных выражений. В частности, это символ `[`, который используется для создания произвольного символьного класса. Полный список выглядит следующим образом:

 - `.`: подстановочный знак (wildcard), используется в тех случаях, когда необходимо указать, что на этом месте может быть любой знак
 
 - `\`: используется для экранирования метасимволов

 - `|` : логический оператор `или`

 - `(` и `)`: используются для указания групп символов

 - `[`: вместе с `]` используется для указания символьных классов

 - `^`: якорь, указывающий на начало строки, а так же логический оператор отрицания, используемый в символьных классах

 - `$`: якорь, указывающий на конец строки
 
 - `*`, `+` и `?` - квантификаторы, указывающие, что предыдущий символ или группа символов могут или должны повториться некоторое количество раз
 
 - `{`: вместе с `}` исползуется как квантификатор, указывающий конкретное количество повторений предыдущего символа или группы символов
 
 - `<` и `>`: используется в Perl-совместимых регулярных выражениях

Для того, чтобы эти метасимволы воспринимались не как элементы языка регулярных выражений, а как есть, их необходимо экранировать двумя символами `\\`. Необходимость в двух символах `\\` для экранирования возникает из-за того, что строковая запись регулярного выражения в R и собственно выражение на языке регулярных выражений несколько различаются. В частности, интерпретатор R также воспринимает обратный слеш как символ экранирования:

```{r 08-handling-with-strings-21 }
string_with_escapes <- c('\\a', '\\z', '\\')
writeLines(string_with_escapes)
```

Таким образом, если мы хотим удалить из строки символы, которые могут быть проинтерпретированы как управляющие конструкции на языке регулярных выражений, мы должны либо экранировать эти символы двумя обратными слешами `\\`, либо в функции, использующей регулярное выражение, задавать аргумент `fixed = TRUE`):
```{r 08-handling-with-strings-22 }
# пробуем удалить символы .* без экранирования
gsub('.*', '_DELETED_', 'metachara.*cters')

# пробудем удалить с экранированием каждого символа
gsub('\\.\\*', '_DELETED_', 'metachara.*cters')

# используем аргумент fixed = TRUE, чтобы воспринимать паттерн не как регулярное выражение
gsub('.*', '_DELETED_', 'metachara.*cters', fixed = TRUE)

```


### Логические операции {#strings-logic}
В регулярных выражениях логические операции представлены в достаточно ограниченном виде, можно даже сказать, крайне бедно. Наиболее очевидная из существующих операции - это `ИЛИ`, когда надо задать несколько вариантов комбинаций символов. В частности, это крайне полезный инструмент для фильтрации вектора строковых значений по определенному критерию. Например, регулярными выражениями с логическим оператором можно просто выделить из списка логов те файлы, которые были созданы в 2015-2016 годах:
```{r 08-handling-with-strings-23 }
models <- c('log_2014.csv', 'log_2015.csv', 'log_2016.csv', 'log_2017.csv', 'log_2018.csv')
models[grep('2015|2016', models)]
```
Второй логический оператор - `^`, используется в тех случаях, когда надо исключить символы определенного класса. Следует помнить, что `^` используется в этом значении сугубо внутри `[]`, в противном случае будет интерпретироваться в другом значении.
```{r 08-handling-with-strings-24 }
# заменяем на '_' любой из символов d, e, f
gsub('[def]', '_', 'fadbcdefghe')

# заменяем на '_' все, кроме символов d, e, f
gsub('[^def]', '_', 'fadbcdefghe')
```

### Квантификаторы {#strings-quantificators}
Для того, чтобы в паттерне указать, что какой-то символ или группа символов может повторяться, используют специальные управляющие знаки - квантификаторы:

 - `?`: предыдущий символ или группа символов в паттерне может встречаться 0 или 1 раз. Также вместе с другими квантификаторами используется для нежадного поиска.

 - `*`: предыдущий символ или группа символов в паттерне может встречаться 0 или больше раз.

 - `+`: предыдущий символ или группа символов в паттерне может встречаться 1 или больше раз.

 - `{n}`: предыдущий символ или группа символов может встречаться в паттерно строго `n` раз.

 - `{n,}`: предыдущий символ или группа символов может встречаться в паттерно `n` и более раз. Конструкции `{0,}` и `{1,}` тождественны `*` и `+` соответственно.

 - `{n,m}`: предыдущий символ или группа символов может встречаться в паттерно `n` раз, но не более, чем `m` раз. Конструкции `{0,1}` и `?` тождественны.

Простейший пример использования квантификаторов - когда надо обработать какой-то символ, который встречается несколько раз. Например, скрыть последние четыре цифры в номере телефона:
```{r 08-handling-with-strings-25 }
phone_number <- 'my phone number: +7-929-138-5896'
gsub('[0-9]{4}', 'XXXX', phone_number)
```

### Подстановочные знаки {#strings-wildecards}
Подстановочные знаки используются в тех ситуациях, когда надо просто указать, что в этом месте может быть любой символ. Несмотря на множественное число (wildcards), в регулярных выражениях в качестве подстановочного знака используется только метасимвол `.`, который обозначает `любой знак`.

Обычно подстановочный знак используется в сочетании с квантификаторами, указывающими, что в этом месте может быть любое количество символов. Например, использование подстановочных знаков может помочь строку, из которой известно только несколько символов. Попробуем из списка строк выбрать только адреса электронной почты в домене ru, исходя из предположения, что требуемые адреса содержат знак `@` и сочетание `.ru`:

```{r 08-handling-with-strings-26 }
emails <- c('myemail@yahoo.com', 'id638@yandex.ru', 'simple string', 'lizzy@mail.ru', 'pumpkinpie@gmail.com')
emails[grep('@.+\\.ru', emails)]
```

### Якори {#strings-anchors}
Якори используются для обозначения, что сочетание символов в паттерне обязательно должно начинать или завершать строку. Также есть якори, которые маркируют начало или конец не строки, а слова, однако само определение слова зависит от используемой локали. В R используются следующие якори:

- `^` и `$`: начало и конец строки соответственно

- `\\<` и `\\>`: начало и конец слова

- `\\b`: пустая строка или края слова

- `\\B`: не край слова

Простым примером может быть выбор и чтение только `xls`-файлов, с игнорированием `xlsx`-файлов или прочих файлов в папке. Так же при импорте файлов MS Office нередко приходится игнорировать еще и временные файлы, которые создаются при работе с файлом MS Office и обычно скрыты от пользователя (их можно отличить по символам `~$` в начале назания файла). Для этого надо указать, что в начале названия строки нет маркеров временных файлов или что название файла начинается с требуемого буквосочетания. Так же надо указать, что файл заканчивается строго на `xls`. Символы в названии, которые находятся между символами, используемыми в начале и конце строки, можно задать с помощью подстановочного знака и квантификатора (`.*`):
```{r 08-handling-with-strings-27 }
files <- c('report_2018.xlsx', 'report2017.xlsx', '~$report2016.xls', 'report2016.xls', 'report2015.xls', 'report2015.doc')

# пробуем извлечь xls-файлы c указанием якорей:
files[grep('^report.*xls$', files)]
files[grep('^[^~$].*xls$', files)]
```

### Группы {#strings-groups}
Квантификаторы обычно работают относительно предыдущего указанного символа. Однако нередко возникают ситуации, когда требуется провести какую-то операцию над определенной группой символов. В таких случаях используют знаки группировки - `(` и `)`. Набор символов и/или выражение, заключенные в скобки, будут восприниматься как неразрывная последовательность символов, и обрабатываться соответствующим образом. 
Например, если мы хотим удалить из строки строго двукратное повторение группы символов:
```{r 08-handling-with-strings-28 }
my_string <- c('abRababL')

# пробуем удалить пару символов без указания группы
gsub('ab', '_DELETED_', my_string)

# группируем символы с помощью ()
gsub('(ab){2}', '_DELETED_', my_string)
```


При необходимости всю обрабатываемую строку можно, с помощью символьных классов, групп и прочих инструментов регулярных выражений, представить в паттерне. При подобном представлении группы нумеруются и может быть обработана конкретная группа символов, вызванная по номеру. Номера групп обозначаются как `\\1`-`\\9`.

Например, в строке есть как текст, так и номер телефона, и мы хотим извлечь все, кроме текста и кода страны. Для этого мы пишем паттерн, который описывает всю строку, и необходимые нам части строки представляем в виде групп. Далее с помощью `gsub()` мы изменяем исходную строку так, что в ней остаются только требуемые нам группы из кодирующих телефонный номер:
```{r 08-handling-with-strings-29 }
phone_number <- 'my phone number: +7-929-138-58-96'
phone_number <- 'my phone number: +7-929-1385896'

phone_pattern <- '.+(\\+[0-9]*)-?([0-9]{3})-?([0-9]{3})-?([0-9]{2})-?([0-9]{2})'
gsub(phone_pattern, '\\2-\\3-\\4\\5', phone_number)
```

В примере выше конструкция `.+` обозначает все возможные символы до группы `(\\+[0-9]*)`, которая, в свою очередь, обозначает численный код страны. Код страны может сстоять как из одной цифры, так и из нескольких. Конструкция `-?` нужна для того, чтобы учесть ситуации, когда номер телефона записывается с разделителями, расставленными в произвольном порядке (`+7-929-138-5896` vs `+79291385896` vs `+7-929-138-58-96` и т.д.). Группы `([0-9]{3})`, `([0-9]{2})` обозначают, собственно, сколько раз должны повторяться цифры в этой группе символов.

В результате в паттерне оказывается представлена вся строка, а элементы номера телефона представлены в виде пяти групп. Функция `sub()` находит в строке совпадение с паттерном и замещает строку на набор групп, `\\2-\\3-\\4\\5`, притом, четвертая и пятая группы сознательно не разделены знаком `-`, чтобы в результате последние четыре цифры номера были целостным блоком. Так как паттерн кодирует всю строку, то, в результате мы получаем только те части строки, которые описываются группами. В нашем случае это номер телефона без указания кода страны.